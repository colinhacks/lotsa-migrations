"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$expr_PathNode = exports.$expr_PathLeaf = exports.$pathify = exports.$expressionify = void 0;
const reflection_1 = require("../reflection");
const toEdgeQL_1 = require("./toEdgeQL");
const std_1 = __importDefault(require("@generated/modules/std"));
function _$expr_PathLeaf(root, parent, exclusive) {
    return $expressionify({
        __kind__: reflection_1.ExpressionKind.PathLeaf,
        __element__: root.__element__,
        __cardinality__: root.__cardinality__,
        __parent__: parent,
        __exclusive__: exclusive,
    });
}
exports.$expr_PathLeaf = _$expr_PathLeaf;
function _$expr_PathNode(root, parent, exclusive) {
    const pathNode = $expressionify({
        __kind__: reflection_1.ExpressionKind.PathNode,
        __element__: root.__element__,
        __cardinality__: root.__cardinality__,
        __parent__: parent,
        __exclusive__: exclusive,
    });
    return pathNode;
}
exports.$expr_PathNode = _$expr_PathNode;
const pathCache = Symbol();
function _$pathify(_root) {
    if (_root.__element__.__kind__ !== reflection_1.TypeKind.object) {
        return _root;
    }
    const root = _root;
    root[pathCache] = {};
    for (const line of Object.entries(root.__element__.__pointers__)) {
        const [key, _ptr] = line;
        const ptr = _ptr;
        if (ptr.__kind__ === "property") {
            Object.defineProperty(root, key, {
                get() {
                    var _a;
                    return ((_a = root[pathCache][key]) !== null && _a !== void 0 ? _a : (root[pathCache][key] = _$expr_PathLeaf({
                        __element__: ptr.target,
                        __cardinality__: reflection_1.cardinalityUtil.multiplyCardinalities(root.__cardinality__, ptr.cardinality),
                    }, {
                        linkName: key,
                        type: root,
                    }, ptr.exclusive)));
                },
                enumerable: true,
            });
        }
        else {
            Object.defineProperty(root, key, {
                get: () => {
                    var _a;
                    return ((_a = root[pathCache][key]) !== null && _a !== void 0 ? _a : (root[pathCache][key] = _$expr_PathNode({
                        __element__: ptr.target,
                        __cardinality__: reflection_1.cardinalityUtil.multiplyCardinalities(root.__cardinality__, ptr.cardinality),
                    }, {
                        linkName: key,
                        type: root,
                    }, ptr.exclusive)));
                },
                enumerable: true,
            });
        }
    }
    return root;
}
exports.$pathify = _$pathify;
function isFunc(expr) {
    return $expressionify({
        __kind__: reflection_1.ExpressionKind.TypeIntersection,
        __cardinality__: this.__cardinality__,
        __element__: {
            ...expr.__element__,
            __shape__: { id: true },
        },
        __expr__: this,
    });
}
function $expressionify(_expr) {
    const expr = _expr;
    expr.$is = isFunc.bind(expr);
    expr.toEdgeQL = toEdgeQL_1.$toEdgeQL.bind(expr);
    _$pathify(expr);
    expr.$assertSingle = () => std_1.default.assert_single(expr);
    return Object.freeze(expr);
}
exports.$expressionify = $expressionify;
