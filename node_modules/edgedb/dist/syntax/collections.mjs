import { cardinalityUtil, ExpressionKind, TypeKind, } from "../reflection";
import { $expressionify } from "./path";
export function array(arg) {
    if (Array.isArray(arg)) {
        const items = arg;
        return $expressionify({
            __kind__: ExpressionKind.Array,
            __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(items.map(item => item.__cardinality__)),
            __element__: {
                __kind__: TypeKind.array,
                __name__: `array<${items[0].__element__.__name__}>`,
                __element__: items[0].__element__,
            },
            __items__: items,
        });
    }
    if (arg.__kind__) {
        return {
            __kind__: TypeKind.array,
            __name__: `array<${arg.__name__}>`,
            __element__: arg,
        };
    }
    throw new Error("Invalid array input.");
}
function makeTupleType(name, items) {
    return {
        __kind__: TypeKind.tuple,
        __name__: name,
        __items__: items,
    };
}
export function tuple(_items) {
    if (_items.every(item => !!item.__element__)) {
        const items = _items;
        const name = `tuple<${items
            .map(item => item.__element__.__name__)
            .join(", ")}>`;
        return $expressionify({
            __kind__: ExpressionKind.Tuple,
            __element__: makeTupleType(name, items.map(item => item.__element__)),
            __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(items.map(i => i.__cardinality__)),
            __items__: items,
        });
    }
    if (_items.every(item => Object.values(TypeKind).includes(item.__kind__))) {
        const items = _items;
        const name = `tuple<${items.map(item => item.__name__).join(", ")}>`;
        return makeTupleType(name, items);
    }
    throw new Error("Invalid tuple input.");
}
export function namedTuple(shape) {
    if (Object.values(shape).every((el) => !!el.__element__)) {
        const exprShape = shape;
        const name = `tuple<${Object.entries(exprShape)
            .map(([key, val]) => `${key}: ${val.__element__.__name__}`)
            .join(", ")}>`;
        const typeShape = {};
        for (const key of Object.keys(exprShape)) {
            typeShape[key] = exprShape[key].__element__;
        }
        return $expressionify({
            __kind__: ExpressionKind.NamedTuple,
            __element__: {
                __kind__: TypeKind.namedtuple,
                __name__: name,
                __shape__: typeShape,
            },
            __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic(Object.values(exprShape).map(val => val.__cardinality__)),
            __shape__: exprShape,
        });
    }
    if (Object.values(shape).every((el) => Object.values(TypeKind).includes(el.__kind__))) {
        const name = `tuple<${Object.entries(shape)
            .map(([key, val]) => `${key}: ${val.__name__}`)
            .join(", ")}>`;
        return {
            __kind__: TypeKind.namedtuple,
            __name__: name,
            __shape__: shape,
        };
    }
    throw new Error("Invalid named tuple input.");
}
