"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.select = exports.$selectify = exports.is = exports.EMPTY_LAST = exports.EMPTY_FIRST = exports.DESC = exports.ASC = void 0;
const std_1 = __importDefault(require("@generated/modules/std"));
const reflection_1 = require("../reflection");
const path_1 = require("./path");
const query_1 = require("./query");
exports.ASC = "ASC";
exports.DESC = "DESC";
exports.EMPTY_FIRST = "EMPTY FIRST";
exports.EMPTY_LAST = "EMPTY LAST";
function is(expr, shape) {
    const mappedShape = {};
    for (const [key, value] of Object.entries(shape)) {
        mappedShape[key] = {
            __kind__: reflection_1.ExpressionKind.PolyShapeElement,
            __polyType__: expr,
            __shapeElement__: value,
        };
    }
    return mappedShape;
}
exports.is = is;
function computeFilterCardinality(expr, cardinality, base) {
    var _a, _b, _c;
    let card = cardinality;
    const filter = expr;
    const baseIsObjectExpr = ((_a = base === null || base === void 0 ? void 0 : base.__element__) === null || _a === void 0 ? void 0 : _a.__kind__) === reflection_1.TypeKind.object;
    const filterExprIsEq = filter.__kind__ === reflection_1.ExpressionKind.Operator &&
        filter.__name__ === "std::=";
    const arg0 = (_b = filter === null || filter === void 0 ? void 0 : filter.__args__) === null || _b === void 0 ? void 0 : _b[0];
    const arg1 = (_c = filter === null || filter === void 0 ? void 0 : filter.__args__) === null || _c === void 0 ? void 0 : _c[1];
    const argsExist = !!arg0 && !!arg1 && !!arg1.__cardinality__;
    const arg0IsUnique = (arg0 === null || arg0 === void 0 ? void 0 : arg0.__exclusive__) === true;
    const newCard = arg1.__cardinality__ === reflection_1.Cardinality.One ||
        arg1.__cardinality__ === reflection_1.Cardinality.AtMostOne
        ? reflection_1.Cardinality.AtMostOne
        : arg1.__cardinality__ === reflection_1.Cardinality.Empty
            ? reflection_1.Cardinality.Empty
            : cardinality;
    if (baseIsObjectExpr && filterExprIsEq && argsExist && arg0IsUnique) {
        if (arg0.__kind__ === reflection_1.ExpressionKind.PathLeaf) {
            const arg0ParentMatchesBase = arg0.__parent__.type.__element__.__name__ ===
                base.__element__.__name__;
            if (arg0ParentMatchesBase) {
                card = newCard;
            }
        }
        else if (arg0.__kind__ === reflection_1.ExpressionKind.PathNode) {
            const parent = arg0.__parent__;
            if (parent === null) {
                const arg0MatchesBase = arg0.__element__.__name__ === base.__element__.__name__;
                if (arg0MatchesBase) {
                    card = newCard;
                }
            }
            else {
                const arg0ParentMatchesBase = (parent === null || parent === void 0 ? void 0 : parent.type.__element__.__name__) === base.__element__.__name__;
                if (arg0ParentMatchesBase) {
                    card = newCard;
                }
            }
        }
    }
    return card;
}
function handleModifiers(modifiers, rootExpr) {
    const mods = { ...modifiers };
    let card = rootExpr.__cardinality__;
    if (mods.filter) {
        card = computeFilterCardinality(mods.filter, card, rootExpr);
    }
    if (mods.order) {
        const orderExprs = Array.isArray(mods.order) ? mods.order : [mods.order];
        mods.order = orderExprs.map(expr => typeof expr.__element__ === "undefined"
            ? expr
            : { expression: expr });
    }
    if (mods.offset) {
        mods.offset =
            typeof mods.offset === "number" ? std_1.default.int64(mods.offset) : mods.offset;
    }
    if (mods.limit) {
        let expr = mods.limit;
        if (typeof expr === "number") {
            expr = std_1.default.int64(expr);
        }
        else if (expr.__kind__ === reflection_1.ExpressionKind.Set) {
            expr = expr.__exprs__[0];
        }
        mods.limit = expr;
        if (expr.__kind__ === reflection_1.ExpressionKind.Literal) {
            const literalExpr = expr;
            if (literalExpr.__value__ === 1) {
                card = reflection_1.Cardinality.AtMostOne;
            }
            else if (literalExpr.__value__ === 0) {
                card = reflection_1.Cardinality.Empty;
            }
        }
    }
    return { modifiers: mods, cardinality: card };
}
function updateFunc(shape) {
    return (0, path_1.$expressionify)((0, query_1.$queryify)({
        __kind__: reflection_1.ExpressionKind.Update,
        __element__: this.__element__,
        __cardinality__: this.__cardinality__,
        __expr__: this,
        __shape__: shape,
    }));
}
function deleteFunc() {
    return (0, path_1.$expressionify)((0, query_1.$queryify)({
        __kind__: reflection_1.ExpressionKind.Delete,
        __element__: this.__element__,
        __cardinality__: this.__cardinality__,
        __expr__: this,
    }));
}
function $selectify(expr) {
    Object.assign(expr, {
        update: updateFunc.bind(expr),
        delete: deleteFunc.bind(expr),
    });
    return (0, query_1.$queryify)(expr);
}
exports.$selectify = $selectify;
function select(...args) {
    const [expr, shapeGetter] = typeof args[0].__element__ !== "undefined"
        ? args
        : [std_1.default.FreeObject, () => args[0]];
    if (!shapeGetter) {
        if (expr.__element__.__kind__ === reflection_1.TypeKind.object) {
            const objectExpr = expr;
            return (0, path_1.$expressionify)($selectify({
                __kind__: reflection_1.ExpressionKind.Select,
                __element__: {
                    __kind__: reflection_1.TypeKind.object,
                    __name__: `${objectExpr.__element__.__name__}`,
                    __pointers__: objectExpr.__element__.__pointers__,
                    __shape__: { id: true },
                },
                __cardinality__: objectExpr.__cardinality__,
                __expr__: objectExpr,
                __modifiers__: {},
            }));
        }
        else {
            return (0, path_1.$expressionify)((0, query_1.$queryify)({
                __kind__: reflection_1.ExpressionKind.Select,
                __element__: expr.__element__,
                __cardinality__: expr.__cardinality__,
                __expr__: expr,
                __modifiers__: {},
            }));
        }
    }
    const objExpr = expr;
    const { modifiers: mods, shape, scope, expr: selectExpr, } = resolveShape(shapeGetter, objExpr);
    if (selectExpr) {
        return (0, path_1.$expressionify)((0, query_1.$queryify)({
            __kind__: reflection_1.ExpressionKind.Select,
            __element__: selectExpr.__element__,
            __cardinality__: reflection_1.cardinalityUtil.multiplyCardinalities(selectExpr.__cardinality__, objExpr.__cardinality__),
            __expr__: selectExpr,
            __modifiers__: {},
            __scope__: scope,
        }));
    }
    const { modifiers, cardinality } = handleModifiers(mods, objExpr);
    return (0, path_1.$expressionify)($selectify({
        __kind__: reflection_1.ExpressionKind.Select,
        __element__: {
            __kind__: reflection_1.TypeKind.object,
            __name__: `${objExpr.__element__.__name__}`,
            __pointers__: objExpr.__element__.__pointers__,
            __shape__: shape,
        },
        __cardinality__: cardinality,
        __expr__: expr,
        __modifiers__: modifiers,
        __scope__: expr !== std_1.default.FreeObject ? scope : undefined,
    }));
}
exports.select = select;
function resolveShape(shapeGetter, expr) {
    const modifiers = {};
    const shape = {};
    const scope = (0, path_1.$expressionify)({
        ...expr,
        __cardinality__: reflection_1.Cardinality.One,
    });
    const selectShape = typeof shapeGetter === "function" ? shapeGetter(scope) : shapeGetter;
    if (typeof selectShape.__kind__ !== "undefined") {
        return { expr: selectShape, shape, modifiers, scope };
    }
    for (const [key, value] of Object.entries(selectShape)) {
        if (key === "filter" ||
            key === "order" ||
            key === "offset" ||
            key === "limit") {
            modifiers[key] = value;
        }
        else {
            shape[key] = resolveShapeElement(key, value, scope);
        }
    }
    return { shape, modifiers, scope };
}
function resolveShapeElement(key, value, scope) {
    var _a, _b;
    if ((typeof value === "function" &&
        ((_a = scope.__element__.__pointers__[key]) === null || _a === void 0 ? void 0 : _a.__kind__) === "link") ||
        (typeof value === "object" &&
            typeof value.__kind__ === "undefined")) {
        const childExpr = scope[key];
        const { shape: childShape, scope: childScope } = resolveShape(value, childExpr);
        return {
            __kind__: reflection_1.ExpressionKind.Select,
            __element__: {
                __kind__: reflection_1.TypeKind.object,
                __name__: `${childExpr.__name__}`,
                __pointers__: childExpr.__pointers__,
                __shape__: childShape,
            },
            __cardinality__: scope.__element__.__pointers__[key].cardinality,
            __expr__: childExpr,
            __modifiers__: {},
            __scope__: childScope,
        };
    }
    else if (((_b = value) === null || _b === void 0 ? void 0 : _b.__kind__) === reflection_1.ExpressionKind.PolyShapeElement) {
        const polyElement = value;
        const polyScope = scope.$is(polyElement.__polyType__);
        return {
            __kind__: reflection_1.ExpressionKind.PolyShapeElement,
            __polyType__: polyScope,
            __shapeElement__: resolveShapeElement(key, polyElement.__shapeElement__, polyScope),
        };
    }
    else {
        return value;
    }
}
