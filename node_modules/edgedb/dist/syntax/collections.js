"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.namedTuple = exports.tuple = exports.array = void 0;
const reflection_1 = require("../reflection");
const path_1 = require("./path");
function array(arg) {
    if (Array.isArray(arg)) {
        const items = arg;
        return (0, path_1.$expressionify)({
            __kind__: reflection_1.ExpressionKind.Array,
            __cardinality__: reflection_1.cardinalityUtil.multiplyCardinalitiesVariadic(items.map(item => item.__cardinality__)),
            __element__: {
                __kind__: reflection_1.TypeKind.array,
                __name__: `array<${items[0].__element__.__name__}>`,
                __element__: items[0].__element__,
            },
            __items__: items,
        });
    }
    if (arg.__kind__) {
        return {
            __kind__: reflection_1.TypeKind.array,
            __name__: `array<${arg.__name__}>`,
            __element__: arg,
        };
    }
    throw new Error("Invalid array input.");
}
exports.array = array;
function makeTupleType(name, items) {
    return {
        __kind__: reflection_1.TypeKind.tuple,
        __name__: name,
        __items__: items,
    };
}
function tuple(_items) {
    if (_items.every(item => !!item.__element__)) {
        const items = _items;
        const name = `tuple<${items
            .map(item => item.__element__.__name__)
            .join(", ")}>`;
        return (0, path_1.$expressionify)({
            __kind__: reflection_1.ExpressionKind.Tuple,
            __element__: makeTupleType(name, items.map(item => item.__element__)),
            __cardinality__: reflection_1.cardinalityUtil.multiplyCardinalitiesVariadic(items.map(i => i.__cardinality__)),
            __items__: items,
        });
    }
    if (_items.every(item => Object.values(reflection_1.TypeKind).includes(item.__kind__))) {
        const items = _items;
        const name = `tuple<${items.map(item => item.__name__).join(", ")}>`;
        return makeTupleType(name, items);
    }
    throw new Error("Invalid tuple input.");
}
exports.tuple = tuple;
function namedTuple(shape) {
    if (Object.values(shape).every((el) => !!el.__element__)) {
        const exprShape = shape;
        const name = `tuple<${Object.entries(exprShape)
            .map(([key, val]) => `${key}: ${val.__element__.__name__}`)
            .join(", ")}>`;
        const typeShape = {};
        for (const key of Object.keys(exprShape)) {
            typeShape[key] = exprShape[key].__element__;
        }
        return (0, path_1.$expressionify)({
            __kind__: reflection_1.ExpressionKind.NamedTuple,
            __element__: {
                __kind__: reflection_1.TypeKind.namedtuple,
                __name__: name,
                __shape__: typeShape,
            },
            __cardinality__: reflection_1.cardinalityUtil.multiplyCardinalitiesVariadic(Object.values(exprShape).map(val => val.__cardinality__)),
            __shape__: exprShape,
        });
    }
    if (Object.values(shape).every((el) => Object.values(reflection_1.TypeKind).includes(el.__kind__))) {
        const name = `tuple<${Object.entries(shape)
            .map(([key, val]) => `${key}: ${val.__name__}`)
            .join(", ")}>`;
        return {
            __kind__: reflection_1.TypeKind.namedtuple,
            __name__: name,
            __shape__: shape,
        };
    }
    throw new Error("Invalid named tuple input.");
}
exports.namedTuple = namedTuple;
