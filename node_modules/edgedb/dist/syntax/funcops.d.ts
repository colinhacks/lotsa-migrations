import { Expression, BaseType, BaseTypeSet, Cardinality, ExpressionKind, introspect, OperatorKind, TypeSet } from "../reflection";
export declare type $expr_Function<Name extends string = string, Args extends (BaseTypeSet | undefined)[] = (BaseTypeSet | undefined)[], NamedArgs extends {
    [key: string]: BaseTypeSet;
} = {
    [key: string]: BaseTypeSet;
}, ReturnType extends BaseTypeSet = BaseTypeSet> = Expression<{
    __element__: ReturnType["__element__"];
    __cardinality__: ReturnType["__cardinality__"];
    __kind__: ExpressionKind.Function;
    __name__: Name;
    __args__: Args;
    __namedargs__: NamedArgs;
}>;
export declare type $expr_Operator<Name extends string = string, OpKind extends OperatorKind = OperatorKind, Args extends TypeSet[] = TypeSet[], ReturnType extends TypeSet = TypeSet> = Expression<{
    __element__: ReturnType["__element__"];
    __cardinality__: ReturnType["__cardinality__"];
    __kind__: ExpressionKind.Operator;
    __name__: Name;
    __opkind__: OpKind;
    __args__: Args;
}>;
interface OverloadFuncArgDef {
    typeId: string;
    optional?: boolean;
    setoftype?: boolean;
    variadic?: boolean;
}
interface OverloadFuncDef {
    kind?: string;
    args: OverloadFuncArgDef[];
    namedArgs?: {
        [key: string]: OverloadFuncArgDef;
    };
    returnTypeId: string;
    returnTypemod?: "SetOfType" | "OptionalType";
    preservesOptionality?: boolean;
}
export declare function $resolveOverload(args: any[], typeSpec: introspect.Types, funcDefs: OverloadFuncDef[]): {
    kind?: string | undefined;
    returnType: BaseType;
    cardinality: Cardinality;
    args: BaseTypeSet[];
    namedArgs: {
        [key: string]: BaseTypeSet;
    };
};
export {};
