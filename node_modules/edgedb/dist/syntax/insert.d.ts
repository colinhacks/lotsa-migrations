import { Cardinality, Expression, ExpressionKind, LinkDesc, ObjectTypeSet, ObjectTypePointers, PropertyDesc, stripBacklinks, stripNonWritables, typeutil, $scopify, stripSet, TypeSet, QueryableExpression } from "../reflection";
import type { pointerToAssignmentExpression } from "./casting";
import { $expr_PathNode } from "../reflection/path";
declare type pointerIsOptional<T extends PropertyDesc | LinkDesc> = T["cardinality"] extends Cardinality.Many | Cardinality.Empty | Cardinality.AtMostOne ? true : false;
export declare type InsertShape<Root extends ObjectTypeSet> = typeutil.stripNever<stripNonWritables<stripBacklinks<Root["__element__"]["__pointers__"]>>> extends infer Shape ? Shape extends ObjectTypePointers ? typeutil.addQuestionMarks<{
    [k in keyof Shape]: pointerToAssignmentExpression<Shape[k]> | (pointerIsOptional<Shape[k]> extends true ? undefined : never);
}> : never : never;
interface UnlessConflict {
    on: TypeSet | null;
    else?: TypeSet;
}
declare type InsertBaseExpression<Root extends TypeSet = TypeSet> = {
    __kind__: ExpressionKind.Insert;
    __element__: Root["__element__"];
    __cardinality__: Cardinality.One;
    __expr__: stripSet<Root>;
    __shape__: any;
};
export declare type $expr_Insert<Root extends $expr_PathNode = $expr_PathNode> = QueryableExpression<{
    __kind__: ExpressionKind.Insert;
    __element__: Root["__element__"];
    __cardinality__: Cardinality.One;
    __expr__: Root;
    __shape__: InsertShape<Root>;
    unlessConflict(): $expr_InsertUnlessConflict<Expression<{
        __kind__: ExpressionKind.Insert;
        __element__: Root["__element__"];
        __cardinality__: Cardinality.One;
        __expr__: Root;
        __shape__: InsertShape<Root>;
    }>, {
        on: null;
    }>;
    unlessConflict<Conflict extends UnlessConflict>(conflictGetter: (scope: $scopify<Root["__element__"]>) => Conflict): $expr_InsertUnlessConflict<Expression<{
        __kind__: ExpressionKind.Insert;
        __element__: Root["__element__"];
        __cardinality__: Cardinality.One;
        __expr__: Root;
        __shape__: InsertShape<Root>;
    }>, Conflict>;
}>;
export declare type $expr_InsertUnlessConflict<Root extends InsertBaseExpression = InsertBaseExpression, Conflict extends UnlessConflict = UnlessConflict> = QueryableExpression<{
    __kind__: ExpressionKind.InsertUnlessConflict;
    __element__: Root["__element__"];
    __cardinality__: Cardinality.One;
    __expr__: Root;
    __conflict__: Conflict;
}>;
export declare function $insertify(expr: Omit<$expr_Insert, "unlessConflict">): $expr_Insert;
export declare function insert<Root extends $expr_PathNode>(root: Root, shape: InsertShape<Root>): $expr_Insert<Root>;
export {};
