import { cardinalityUtil, ExpressionKind, TypeKind, } from "../reflection";
import { $toEdgeQL } from "./toEdgeQL";
import _std from "@generated/modules/std";
function _$expr_PathLeaf(root, parent, exclusive) {
    return $expressionify({
        __kind__: ExpressionKind.PathLeaf,
        __element__: root.__element__,
        __cardinality__: root.__cardinality__,
        __parent__: parent,
        __exclusive__: exclusive,
    });
}
function _$expr_PathNode(root, parent, exclusive) {
    const pathNode = $expressionify({
        __kind__: ExpressionKind.PathNode,
        __element__: root.__element__,
        __cardinality__: root.__cardinality__,
        __parent__: parent,
        __exclusive__: exclusive,
    });
    return pathNode;
}
const pathCache = Symbol();
function _$pathify(_root) {
    if (_root.__element__.__kind__ !== TypeKind.object) {
        return _root;
    }
    const root = _root;
    root[pathCache] = {};
    for (const line of Object.entries(root.__element__.__pointers__)) {
        const [key, _ptr] = line;
        const ptr = _ptr;
        if (ptr.__kind__ === "property") {
            Object.defineProperty(root, key, {
                get() {
                    var _a;
                    return ((_a = root[pathCache][key]) !== null && _a !== void 0 ? _a : (root[pathCache][key] = _$expr_PathLeaf({
                        __element__: ptr.target,
                        __cardinality__: cardinalityUtil.multiplyCardinalities(root.__cardinality__, ptr.cardinality),
                    }, {
                        linkName: key,
                        type: root,
                    }, ptr.exclusive)));
                },
                enumerable: true,
            });
        }
        else {
            Object.defineProperty(root, key, {
                get: () => {
                    var _a;
                    return ((_a = root[pathCache][key]) !== null && _a !== void 0 ? _a : (root[pathCache][key] = _$expr_PathNode({
                        __element__: ptr.target,
                        __cardinality__: cardinalityUtil.multiplyCardinalities(root.__cardinality__, ptr.cardinality),
                    }, {
                        linkName: key,
                        type: root,
                    }, ptr.exclusive)));
                },
                enumerable: true,
            });
        }
    }
    return root;
}
function isFunc(expr) {
    return $expressionify({
        __kind__: ExpressionKind.TypeIntersection,
        __cardinality__: this.__cardinality__,
        __element__: {
            ...expr.__element__,
            __shape__: { id: true },
        },
        __expr__: this,
    });
}
export function $expressionify(_expr) {
    const expr = _expr;
    expr.$is = isFunc.bind(expr);
    expr.toEdgeQL = $toEdgeQL.bind(expr);
    _$pathify(expr);
    expr.$assertSingle = () => _std.assert_single(expr);
    return Object.freeze(expr);
}
export { _$pathify as $pathify, _$expr_PathLeaf as $expr_PathLeaf, _$expr_PathNode as $expr_PathNode, };
