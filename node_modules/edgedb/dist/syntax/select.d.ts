import type { $anyint, $bool } from "@generated/modules/std";
import _std from "@generated/modules/std";
import { $expr_PolyShapeElement, $scopify, Cardinality, cardinalityUtil, ExpressionKind, LinkDesc, ObjectType, ObjectTypeExpression, ObjectTypePointers, ObjectTypeSet, PropertyDesc, QueryableExpression, ScalarType, stripSet, stripSetShape, TypeSet, typeutil } from "../reflection";
import type { $expr_PathLeaf, $expr_PathNode, ExpressionRoot, PathParent } from "../reflection/path";
import { anonymizeObject } from "./casting";
import type { $expr_Operator } from "./funcops";
import type { $expr_Update, UpdateShape } from "./update";
export declare const ASC: "ASC";
export declare const DESC: "DESC";
export declare const EMPTY_FIRST: "EMPTY FIRST";
export declare const EMPTY_LAST: "EMPTY LAST";
export declare type OrderByDirection = "ASC" | "DESC";
export declare type OrderByEmpty = "EMPTY FIRST" | "EMPTY LAST";
export declare type OrderByExpr = TypeSet<ScalarType, Cardinality>;
export declare type OrderByObjExpr = {
    expression: OrderByExpr;
    direction?: OrderByDirection;
    empty?: OrderByEmpty;
};
export declare type OrderByExpression = OrderByExpr | OrderByObjExpr | [OrderByExpr | OrderByObjExpr, ...(OrderByExpr | OrderByObjExpr)[]];
export declare type OffsetExpression = TypeSet<$anyint, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;
export declare type SelectFilterExpression = TypeSet<$bool, Cardinality>;
export declare type LimitOffsetExpression = TypeSet<$anyint, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;
export declare type LimitExpression = TypeSet<$anyint, Cardinality.Empty | Cardinality.One | Cardinality.AtMostOne>;
export declare type SelectModifierNames = "filter" | "order" | "offset" | "limit";
export declare type SelectModifiers = {
    filter?: SelectFilterExpression;
    order?: OrderByExpression;
    offset?: OffsetExpression | number;
    limit?: LimitExpression | number;
};
export declare type NormalisedSelectModifiers = {
    filter?: SelectFilterExpression;
    order?: OrderByObjExpr[];
    offset?: OffsetExpression;
    limit?: LimitExpression;
};
export declare type $expr_Select<Set extends TypeSet = TypeSet, Expr extends TypeSet = TypeSet, Modifiers extends NormalisedSelectModifiers = NormalisedSelectModifiers> = QueryableExpression<{
    __element__: Set["__element__"];
    __cardinality__: Set["__cardinality__"];
    __expr__: stripSet<Expr>;
    __kind__: ExpressionKind.Select;
    __modifiers__: Modifiers;
    __scope__?: ObjectTypeExpression;
} & (Set extends ObjectTypeSet ? SelectObjectMethods<Set> : {})>;
interface SelectObjectMethods<Root extends ObjectTypeSet> {
    __element__: Root["__element__"];
    __cardinality__: Root["__cardinality__"];
    update(shape: UpdateShape<Root>): $expr_Update<Root, UpdateShape<Root>>;
    delete(): $expr_Delete<Root>;
}
export declare type argCardToResultCard<OpCard extends Cardinality, BaseCase extends Cardinality> = [OpCard] extends [Cardinality.AtMostOne | Cardinality.One] ? Cardinality.AtMostOne : [OpCard] extends [Cardinality.Empty] ? Cardinality.Empty : BaseCase;
export declare type InferFilterCardinality<Base extends TypeSet, Filter extends TypeSet | undefined> = Filter extends TypeSet ? Base extends ObjectTypeSet ? Filter extends $expr_Operator<"std::=", any, infer Args, any> ? Args[0] extends $expr_PathLeaf ? Args[0]["__exclusive__"] extends true ? typeutil.assertEqual<Args[0]["__parent__"]["type"]["__element__"]["__name__"], Base["__element__"]["__name__"]> extends true ? argCardToResultCard<Args[1]["__cardinality__"], Base["__cardinality__"]> : Base["__cardinality__"] : Base["__cardinality__"] : Args[0] extends $expr_PathNode ? Args[0]["__exclusive__"] extends true ? Args[0]["__parent__"] extends null ? typeutil.assertEqual<Args[0]["__element__"]["__name__"], Base["__element__"]["__name__"]> extends true ? argCardToResultCard<Args[1]["__cardinality__"], Base["__cardinality__"]> : Base["__cardinality__"] : Args[0]["__parent__"] extends infer Parent ? Parent extends PathParent ? typeutil.assertEqual<Parent["type"]["__element__"]["__name__"], Base["__element__"]["__name__"]> extends true ? argCardToResultCard<Args[1]["__cardinality__"], Base["__cardinality__"]> : Base["__cardinality__"] : Base["__cardinality__"] : Base["__cardinality__"] : Base["__cardinality__"] : Base["__cardinality__"] : Base["__cardinality__"] : Base["__cardinality__"] : Base["__cardinality__"];
declare type InferLimitCardinality<Card extends Cardinality, Limit extends LimitExpression | number | undefined> = Limit extends number ? Limit extends 0 ? Cardinality.Empty : Limit extends 1 ? Cardinality.AtMostOne : Card : Limit extends LimitExpression ? Limit["__element__"]["__tsconsttype__"] extends 0 ? Cardinality.Empty : Limit["__element__"]["__tsconsttype__"] extends 1 ? Cardinality.AtMostOne : Card : Card;
declare type ComputeSelectCardinality<Expr extends ObjectTypeExpression, Modifiers extends SelectModifiers> = InferLimitCardinality<InferFilterCardinality<Expr, Modifiers["filter"]>, Modifiers["limit"]>;
export declare type polymorphicShape<RawShape extends ObjectTypePointers> = {
    [k in keyof RawShape]?: k extends `<${string}` ? any : RawShape[k] extends PropertyDesc ? boolean : RawShape[k] extends LinkDesc ? boolean | (pointersToSelectShape<RawShape[k]["target"]["__pointers__"]> & pointersToSelectShape<RawShape[k]["properties"]>) | ((scope: $scopify<RawShape[k]["target"]>) => pointersToSelectShape<RawShape[k]["target"]["__pointers__"]> & pointersToSelectShape<RawShape[k]["properties"]>) : any;
};
export declare function is<Expr extends ObjectTypeExpression, Shape extends polymorphicShape<Expr["__element__"]["__pointers__"]>>(expr: Expr, shape: Shape): {
    [k in keyof Shape]: $expr_PolyShapeElement<Expr, Shape[k]>;
};
export declare type $expr_Delete<Root extends ObjectTypeSet = ObjectTypeSet> = QueryableExpression<{
    __kind__: ExpressionKind.Delete;
    __element__: Root["__element__"];
    __cardinality__: Root["__cardinality__"];
    __expr__: Root;
}>;
export declare function $selectify<Expr extends ExpressionRoot>(expr: Expr): Expr & {
    run: (this: any, cxn: import("../ifaces").Executor, args: any) => Promise<any>;
};
export declare type pointersToSelectShape<Shape extends ObjectTypePointers> = Partial<{
    [k in keyof Shape]: Shape[k] extends PropertyDesc ? boolean | TypeSet<Shape[k]["target"], cardinalityUtil.assignable<Shape[k]["cardinality"]>> : Shape[k] extends LinkDesc ? boolean | TypeSet<anonymizeObject<Shape[k]["target"]>, cardinalityUtil.assignable<Shape[k]["cardinality"]>> | (pointersToSelectShape<Shape[k]["target"]["__pointers__"]> & pointersToSelectShape<Shape[k]["properties"]>) | ((scope: $scopify<Shape[k]["target"]>) => pointersToSelectShape<Shape[k]["target"]["__pointers__"]> & pointersToSelectShape<Shape[k]["properties"]>) : any;
}> & SelectModifiers;
export declare function select<Expr extends ObjectTypeExpression>(expr: Expr): $expr_Select<{
    __element__: ObjectType<`${Expr["__element__"]["__name__"]}`, Expr["__element__"]["__pointers__"], {
        id: true;
    }>;
    __cardinality__: Expr["__cardinality__"];
}, Expr>;
export declare function select<Expr extends TypeSet>(expr: Expr): $expr_Select<stripSet<Expr>, Expr>;
export declare function select<Expr extends ObjectTypeExpression, Shape extends pointersToSelectShape<Expr["__element__"]["__pointers__"]>, Modifiers = Pick<Shape, SelectModifierNames>>(expr: Expr, shape: (scope: $scopify<Expr["__element__"]>) => Readonly<Shape>): $expr_Select<{
    __element__: ObjectType<`${Expr["__element__"]["__name__"]}`, Expr["__element__"]["__pointers__"], Omit<stripSetShape<Shape>, SelectModifierNames>>;
    __cardinality__: ComputeSelectCardinality<Expr, Modifiers>;
}, Expr>;
export declare function select<Expr extends ObjectTypeExpression, Set extends TypeSet>(expr: Expr, shape: (scope: $scopify<Expr["__element__"]>) => Set): $expr_Select<{
    __element__: Set["__element__"];
    __cardinality__: cardinalityUtil.multiplyCardinalities<Expr["__cardinality__"], Set["__cardinality__"]>;
}, Expr>;
export declare function select<Shape extends {
    [key: string]: TypeSet;
}>(shape: Shape): $expr_Select<{
    __element__: ObjectType<`std::FreeObject`, {}, Shape>;
    __cardinality__: Cardinality.One;
}, typeof _std.FreeObject>;
export {};
