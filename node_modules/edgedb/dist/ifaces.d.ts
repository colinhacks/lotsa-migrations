/*!
 * This source file is part of the EdgeDB open source project.
 *
 * Copyright 2020-present MagicStack Inc. and the EdgeDB authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="node" />
import { Duration, LocalDate, LocalDateTime, LocalTime, RelativeDuration } from "./datatypes/datetime";
import { RetryOptions, SimpleRetryOptions, SimpleTransactionOptions, TransactionOptions } from "./options";
import { Transaction } from "./transaction";
export declare type ProtocolVersion = [number, number];
declare type QueryArgPrimitive = number | string | boolean | BigInt | Buffer | Date | LocalDateTime | LocalDate | LocalTime | Duration | RelativeDuration;
declare type QueryArg = QueryArgPrimitive | QueryArgPrimitive[] | null;
export declare type QueryArgs = {
    [_: string]: QueryArg;
} | QueryArg[] | null;
export declare enum BorrowReason {
    TRANSACTION = "transaction",
    QUERY = "query",
    CLOSE = "close"
}
export interface ReadOnlyExecutor {
    execute(query: string): Promise<void>;
    query<T = unknown>(query: string, args?: QueryArgs): Promise<T[]>;
    queryJSON(query: string, args?: QueryArgs): Promise<string>;
    querySingle<T = unknown>(query: string, args?: QueryArgs): Promise<T | null>;
    querySingleJSON(query: string, args?: QueryArgs): Promise<string>;
    queryRequiredSingle<T = unknown>(query: string, args?: QueryArgs): Promise<T>;
    queryRequiredSingleJSON(query: string, args?: QueryArgs): Promise<string>;
}
export declare const INNER: unique symbol;
export declare const OPTIONS: unique symbol;
export declare const ALLOW_MODIFICATIONS: unique symbol;
interface Modifiable {
    [ALLOW_MODIFICATIONS]: never;
}
export declare type Executor = ReadOnlyExecutor & Modifiable;
export interface Connection extends Executor {
    rawTransaction<T>(action: (transaction: Transaction) => Promise<T>): Promise<T>;
    retryingTransaction<T>(action: (transaction: Transaction) => Promise<T>): Promise<T>;
    transaction<T>(action: (transaction: Transaction) => Promise<T>): Promise<T>;
    withTransactionOptions(opt: TransactionOptions | SimpleTransactionOptions): Connection;
    withRetryOptions(opt: RetryOptions | SimpleRetryOptions): Connection;
    close(): Promise<void>;
    isClosed(): boolean;
}
export interface IClientStats {
    queueLength: number;
    openConnections: number;
}
export interface Client extends Executor {
    rawTransaction<T>(action: (transaction: Transaction) => Promise<T>): Promise<T>;
    retryingTransaction<T>(action: (transaction: Transaction) => Promise<T>): Promise<T>;
    transaction<T>(action: (transaction: Transaction) => Promise<T>): Promise<T>;
    withTransactionOptions(opt: TransactionOptions | SimpleTransactionOptions): Client;
    withRetryOptions(opt: RetryOptions | SimpleRetryOptions): Client;
    close(): Promise<void>;
    isClosed(): boolean;
    ensureConnected(): Promise<this>;
    getStats(): IClientStats;
    terminate(): void;
}
export interface KnownServerSettings {
    suggested_pool_concurrency?: number;
    system_config?: any;
}
export declare type ServerSettings = KnownServerSettings & {
    [key: string]: Buffer;
};
export declare const HeaderCodes: {
    implicitLimit: number;
    implicitTypenames: number;
    implicitTypeids: number;
    allowCapabilities: number;
};
export declare type MessageHeaders = {
    [key in keyof typeof HeaderCodes]?: string | Buffer;
};
export interface PrepareMessageHeaders {
    implicitLimit?: string;
    implicitTypenames?: "true";
    implicitTypeids?: "true";
}
export interface ParseOptions {
    headers?: PrepareMessageHeaders;
}
export {};
