"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$mergeObjectTypes = exports.makeType = void 0;
const enums_1 = require("./enums");
const util_1 = require("./util/util");
const typeCache = new Map();
function applySpec(spec, type, shape, seen, literal) {
    const allPointers = [
        ...type.pointers,
        ...type.backlinks,
        ...type.backlink_stubs,
    ];
    for (const ptr of allPointers) {
        if (seen.has(ptr.name)) {
            continue;
        }
        seen.add(ptr.name);
        if (ptr.kind === "link") {
            util_1.util.defineGetter(shape, ptr.name, () => {
                return {
                    __kind__: "link",
                    cardinality: ptr.real_cardinality,
                    get target() {
                        return makeType(spec, ptr.target_id, literal);
                    },
                    get properties() {
                        const linkProperties = {};
                        (ptr.pointers || []).forEach(linkProp => {
                            if (linkProp.kind !== "property") {
                                return;
                            }
                            if (linkProp.name === "source" || linkProp.name === "target") {
                                return;
                            }
                            const linkPropObject = {
                                __kind__: "property",
                            };
                            linkPropObject.cardinality = linkProp.real_cardinality;
                            util_1.util.defineGetter(linkPropObject, "target", () => {
                                return makeType(spec, linkProp.target_id, literal);
                            });
                            linkProperties[linkProp.name] = linkPropObject;
                        });
                        return linkProperties;
                    },
                    exclusive: ptr.is_exclusive,
                    writable: ptr.is_writable,
                };
            });
        }
        else if (ptr.kind === "property") {
            util_1.util.defineGetter(shape, ptr.name, () => {
                return {
                    __kind__: "property",
                    cardinality: ptr.real_cardinality,
                    get target() {
                        return makeType(spec, ptr.target_id, literal);
                    },
                    exclusive: ptr.is_exclusive,
                    writable: ptr.is_writable,
                };
            });
        }
    }
}
function makeType(spec, id, literal, anytype) {
    const type = spec.get(id);
    if (typeCache.has(type.name)) {
        return typeCache.get(type.name);
    }
    const obj = {};
    obj.__name__ = type.name;
    if (type.name === "anytype") {
        if (anytype)
            return anytype;
        throw new Error("anytype not provided");
    }
    if (type.kind === "object") {
        obj.__kind__ = enums_1.TypeKind.object;
        util_1.util.defineGetter(obj, "__pointers__", () => {
            const shape = {};
            const seen = new Set();
            applySpec(spec, type, shape, seen, literal);
            const ancestors = [...type.bases];
            for (const anc of ancestors) {
                const ancType = spec.get(anc.id);
                if (ancType.kind === "object" || ancType.kind === "scalar") {
                    ancestors.push(...ancType.bases);
                }
                if (ancType.kind !== "object") {
                    throw new Error(`Not an object: ${id}`);
                }
                applySpec(spec, ancType, shape, seen, literal);
            }
            return shape;
        });
        obj.__shape__ = {};
        obj.__polys__ = [];
        return obj;
    }
    else if (type.kind === "scalar") {
        const scalarObj = ((val) => {
            return literal(scalarObj, val);
        });
        scalarObj.__kind__ = type.enum_values ? enums_1.TypeKind.enum : enums_1.TypeKind.scalar;
        scalarObj.__name__ = type.name;
        if (type.enum_values) {
            for (const val of type.enum_values) {
                scalarObj[val] = val;
            }
        }
        typeCache.set(type.name, scalarObj);
        return scalarObj;
    }
    else if (type.kind === "array") {
        obj.__kind__ = enums_1.TypeKind.array;
        util_1.util.defineGetter(obj, "__element__", () => {
            return makeType(spec, type.array_element_id, literal, anytype);
        });
        util_1.util.defineGetter(obj, "__name__", () => {
            return `array<${obj.__element__.__name__}>`;
        });
        return obj;
    }
    else if (type.kind === "tuple") {
        if (type.tuple_elements[0].name === "0") {
            obj.__kind__ = enums_1.TypeKind.tuple;
            util_1.util.defineGetter(obj, "__items__", () => {
                return type.tuple_elements.map(el => makeType(spec, el.target_id, literal, anytype));
            });
            util_1.util.defineGetter(obj, "__name__", () => {
                return `tuple<${obj.__items__
                    .map((item) => item.__name__)
                    .join(", ")}>`;
            });
            return obj;
        }
        else {
            obj.__kind__ = enums_1.TypeKind.namedtuple;
            util_1.util.defineGetter(obj, "__shape__", () => {
                const shape = {};
                for (const el of type.tuple_elements) {
                    shape[el.name] = makeType(spec, el.target_id, literal, anytype);
                }
                return shape;
            });
            util_1.util.defineGetter(obj, "__name__", () => {
                return `tuple<${Object.entries(obj.__shape__)
                    .map(([key, val]) => `${key}: ${val.__name__}`)
                    .join(", ")}>`;
            });
            return obj;
        }
    }
    else {
        throw new Error("Invalid type.");
    }
}
exports.makeType = makeType;
function $mergeObjectTypes(a, b) {
    const obj = {
        __kind__: enums_1.TypeKind.object,
        __name__: `${a.__name__} UNION ${b.__name__}`,
        get __pointers__() {
            const merged = {};
            for (const [akey, aitem] of Object.entries(a.__pointers__)) {
                if (!b.__pointers__[akey])
                    continue;
                const bitem = b.__pointers__[akey];
                if (aitem.cardinality !== bitem.cardinality)
                    continue;
                if (aitem.target.__name__ !== bitem.target.__name__)
                    continue;
                merged[akey] = aitem;
            }
            return merged;
        },
        __shape__: {},
    };
    return obj;
}
exports.$mergeObjectTypes = $mergeObjectTypes;
