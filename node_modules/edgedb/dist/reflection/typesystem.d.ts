import type { Executor } from "../ifaces";
import type { $expr_TypeIntersection, $pathify, $expr_PathNode } from "./path";
import type { $expr_Literal } from "./literal";
import type { typeutil } from "./util/typeutil";
import { Cardinality, ExpressionKind, TypeKind } from "./enums";
import { cardinalityUtil } from "./util/cardinalityUtil";
export interface BaseType {
    __kind__: TypeKind;
    __name__: string;
}
export declare type BaseTypeSet = {
    __element__: BaseType;
    __cardinality__: Cardinality;
};
export declare type BaseTypeTuple = typeutil.tupleOf<BaseType>;
export interface ScalarType<Name extends string = string, TsType extends any = any, TsConstType extends TsType = TsType> extends BaseType {
    __kind__: TypeKind.scalar;
    __tstype__: TsType;
    __tsconsttype__: TsConstType;
    __name__: Name;
    <T extends TsType = TsType>(val: T): $expr_Literal<ScalarType<Name, TsType, T>>;
}
export interface TypeSet<T extends BaseType = BaseType, Card extends Cardinality = Cardinality> {
    __element__: T;
    __cardinality__: Card;
}
export declare function $toSet<Root extends BaseType, Card extends Cardinality>(root: Root, card: Card): TypeSet<Root, Card>;
export declare type Expression<Set extends TypeSet = TypeSet> = BaseType extends Set["__element__"] ? Set & {
    toEdgeQL(): string;
    $is: any;
    $assertSingle: any;
} : Set & ExpressionMethods<stripSet<Set>> & $pathify<Set>;
export declare type QueryableExpression<Set extends TypeSet = TypeSet> = Expression<Set> & {
    run(cxn: Executor): Promise<setToTsType<Set>>;
};
export declare type stripSet<T> = "__element__" extends keyof T ? "__cardinality__" extends keyof T ? {
    __element__: T["__element__"];
    __cardinality__: T["__cardinality__"];
} : T : T;
export declare type stripSetShape<T> = {
    [k in keyof T]: stripSet<T[k]>;
};
export declare type $assertSingle<Expr extends TypeSet> = Expression<{
    __element__: Expr["__element__"];
    __cardinality__: cardinalityUtil.overrideUpperBound<Expr["__cardinality__"], "One">;
    __kind__: ExpressionKind.Function;
    __name__: "std::assert_single";
    __args__: [TypeSet];
    __namedargs__: {};
}>;
export interface ExpressionMethods<Set extends TypeSet> {
    __element__: Set["__element__"];
    __cardinality__: Set["__cardinality__"];
    toEdgeQL(): string;
    $is<T extends ObjectTypeSet>(ixn: T): $expr_TypeIntersection<{
        __cardinality__: Set["__cardinality__"];
        __element__: Set["__element__"];
    }, ObjectType<T["__element__"]["__name__"], T["__element__"]["__pointers__"], {
        id: true;
    }>>;
    $assertSingle(): $assertSingle<Set>;
}
export interface EnumType<Name extends string = string, TsType extends any = any, Vals extends any = any> extends BaseType {
    __kind__: TypeKind.enum;
    __tstype__: TsType;
    __name__: Name;
    (val: TsType | Vals): $expr_Literal<this>;
}
export declare type ObjectTypeSet = TypeSet<ObjectType, Cardinality>;
export declare type ObjectTypeExpression = TypeSet<ObjectType, Cardinality>;
export interface ObjectType<Name extends string = string, Pointers extends ObjectTypePointers = ObjectTypePointers, Shape extends object | null = any> extends BaseType {
    __kind__: TypeKind.object;
    __name__: Name;
    __pointers__: Pointers;
    __shape__: Shape;
}
export declare type PropertyTypes = ScalarType | EnumType | ArrayType | TupleType | NamedTupleType;
export interface PropertyDesc<Type extends BaseType = BaseType, Card extends Cardinality = Cardinality, Exclusive extends boolean = boolean, Writable extends boolean = boolean> {
    __kind__: "property";
    target: Type;
    cardinality: Card;
    exclusive: Exclusive;
    writable: Writable;
}
export declare type $scopify<Type extends ObjectType> = $expr_PathNode<TypeSet<Type, Cardinality.One>, null, true>;
export declare type PropertyShape = {
    [k: string]: PropertyDesc;
};
export interface LinkDesc<Type extends ObjectType = any, Card extends Cardinality = Cardinality, LinkProps extends PropertyShape = any, Exclusive extends boolean = boolean, Writable extends boolean = boolean> {
    __kind__: "link";
    target: Type;
    cardinality: Card;
    properties: LinkProps;
    exclusive: Exclusive;
    writable: Writable;
}
export declare type ObjectTypePointers = {
    [k: string]: PropertyDesc | LinkDesc;
};
export declare type stripBacklinks<T extends ObjectTypePointers> = {
    [k in keyof T]: k extends `<${string}` ? never : T[k];
};
export declare type omitBacklinks<T extends string | number | symbol> = T extends `<${string}` ? never : T extends string ? T : never;
export declare type stripNonWritables<T extends ObjectTypePointers> = {
    [k in keyof T]: [T[k]["writable"]] extends [true] ? T[k] : never;
};
declare type shapeElementToTs<Pointer extends PropertyDesc | LinkDesc, Element> = [
    Element
] extends [true] ? pointerToTsType<Pointer> : [Element] extends [false] ? never : [Element] extends [boolean] ? pointerToTsType<Pointer> | undefined : Element extends TypeSet ? setToTsType<Element> : Pointer extends LinkDesc ? Element extends (...scope: any[]) => any ? computeObjectShape<Pointer["target"]["__pointers__"] & Pointer["properties"], ReturnType<Element>> : Element extends object ? computeObjectShape<Pointer["target"]["__pointers__"] & Pointer["properties"], Element> : never : never;
export declare type $expr_PolyShapeElement<PolyType extends ObjectTypeSet = ObjectTypeSet, ShapeElement extends any = any> = {
    __kind__: ExpressionKind.PolyShapeElement;
    __polyType__: PolyType;
    __shapeElement__: ShapeElement;
};
export declare type computeObjectShape<Pointers extends ObjectTypePointers, Shape> = typeutil.flatten<keyof Shape extends never ? {
    id: string;
} : {
    [k in keyof Shape]: Shape[k] extends $expr_PolyShapeElement<infer PolyType, infer ShapeEl> ? [k] extends [keyof PolyType["__element__"]["__pointers__"]] ? shapeElementToTs<PolyType["__element__"]["__pointers__"][k], ShapeEl> | null : never : [k] extends [keyof Pointers] ? shapeElementToTs<Pointers[k], Shape[k]> : Shape[k] extends TypeSet ? setToTsType<Shape[k]> : never;
}>;
export declare type pointerToTsTypeSimple<El extends PropertyDesc | LinkDesc> = El extends PropertyDesc ? propToTsType<El> : El extends LinkDesc<any, any, any, any> ? {
    id: string;
} : never;
export declare type PrimitiveType = ScalarType | EnumType | TupleType | NamedTupleType | ArrayType;
export declare type PrimitiveTypeSet = TypeSet<PrimitiveType, Cardinality>;
export declare type $expr_Array<Type extends BaseType = BaseType, Card extends Cardinality = Cardinality> = Expression<{
    __kind__: ExpressionKind.Array;
    __items__: typeutil.tupleOf<TypeSet<Type>>;
    __element__: Type;
    __cardinality__: Card;
}>;
export interface ArrayType<Element extends NonArrayType = NonArrayType, Name extends string = `array<${Element["__name__"]}>`> extends BaseType {
    __name__: Name;
    __kind__: TypeKind.array;
    __element__: Element;
}
declare type ArrayTypeToTsType<Type extends ArrayType> = BaseTypeToTsType<Type["__element__"]>[];
export declare type baseTupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> = {
    [k in keyof T]: T[k] extends TypeSet ? T[k]["__element__"] : never;
};
export declare type tupleElementsToTupleType<T extends typeutil.tupleOf<TypeSet>> = baseTupleElementsToTupleType<T> extends BaseTypeTuple ? TupleType<baseTupleElementsToTupleType<T>> : never;
export declare type baseTupleElementsToCardTuple<T> = {
    [k in keyof T]: T[k] extends TypeSet<any, infer C> ? C : never;
};
export declare type tupleElementsToCardTuple<T> = baseTupleElementsToCardTuple<T> extends [Cardinality, ...Cardinality[]] ? baseTupleElementsToCardTuple<T> : never;
export declare type $expr_Tuple<Items extends typeutil.tupleOf<TypeSet> = typeutil.tupleOf<TypeSet>> = Expression<{
    __kind__: ExpressionKind.Tuple;
    __items__: Items;
    __element__: tupleElementsToTupleType<Items>;
    __cardinality__: cardinalityUtil.multiplyCardinalitiesVariadic<tupleElementsToCardTuple<Items>>;
}>;
export interface TupleType<Items extends BaseTypeTuple = BaseTypeTuple> extends BaseType {
    __name__: string;
    __kind__: TypeKind.tuple;
    __items__: Items;
}
declare type TupleItemsToTsType<Items extends BaseTypeTuple> = {
    [k in keyof Items]: Items[k] extends BaseType ? BaseTypeToTsType<Items[k]> : never;
};
declare type literalShapeToType<T extends NamedTupleLiteralShape> = NamedTupleType<{
    [k in keyof T]: T[k]["__element__"];
}>;
declare type shapeCardinalities<Shape extends NamedTupleLiteralShape> = Shape[keyof Shape]["__cardinality__"];
declare type inferNamedTupleCardinality<Shape extends NamedTupleLiteralShape> = [
    Cardinality.Many
] extends [shapeCardinalities<Shape>] ? Cardinality.Many : [Cardinality.Empty] extends [shapeCardinalities<Shape>] ? Cardinality.Empty : [shapeCardinalities<Shape>] extends [Cardinality.AtMostOne] ? Cardinality.AtMostOne : [shapeCardinalities<Shape>] extends [
    Cardinality.AtMostOne | Cardinality.One
] ? Cardinality.One : Cardinality.Many;
export declare type $expr_NamedTuple<Shape extends NamedTupleLiteralShape = NamedTupleLiteralShape> = Expression<{
    __kind__: ExpressionKind.NamedTuple;
    __element__: literalShapeToType<Shape>;
    __cardinality__: inferNamedTupleCardinality<Shape>;
    __shape__: Shape;
}>;
export declare type NamedTupleLiteralShape = {
    [k: string]: TypeSet;
};
export declare type NamedTupleShape = {
    [k: string]: BaseType;
};
export interface NamedTupleType<Shape extends NamedTupleShape = NamedTupleShape> extends BaseType {
    __name__: string;
    __kind__: TypeKind.namedtuple;
    __shape__: Shape;
}
declare type NamedTupleTypeToTsType<Type extends NamedTupleType> = {
    [k in keyof Type["__shape__"]]: BaseTypeToTsType<Type["__shape__"][k]>;
};
export declare type BaseTypeToTsType<Type extends BaseType> = typeutil.flatten<Type extends ScalarType ? Type["__tsconsttype__"] : Type extends EnumType ? Type["__tstype__"] : Type extends ArrayType ? ArrayTypeToTsType<Type> : Type extends TupleType ? TupleItemsToTsType<Type["__items__"]> : Type extends NamedTupleType ? NamedTupleTypeToTsType<Type> : Type extends ObjectType ? computeObjectShape<Type["__pointers__"], Type["__shape__"]> : never>;
export declare type setToTsType<Set extends TypeSet> = computeTsType<Set["__element__"], Set["__cardinality__"]>;
export declare type computeTsType<T extends BaseType, C extends Cardinality> = Cardinality extends C ? unknown : BaseType extends T ? unknown : C extends Cardinality.Empty ? null : C extends Cardinality.One ? BaseTypeToTsType<T> : C extends Cardinality.AtLeastOne ? [BaseTypeToTsType<T>, ...BaseTypeToTsType<T>[]] : C extends Cardinality.AtMostOne ? BaseTypeToTsType<T> | null : C extends Cardinality.Many ? BaseTypeToTsType<T>[] : C extends Cardinality ? unknown : never;
export declare type propToTsType<Prop extends PropertyDesc> = Prop extends PropertyDesc<infer Type, infer Card> ? setToTsType<TypeSet<Type, Card>> : never;
export declare type linkToTsType<Link extends LinkDesc> = computeTsType<Link["target"], Link["cardinality"]>;
export declare type pointerToTsType<El extends PropertyDesc | LinkDesc> = El extends PropertyDesc ? propToTsType<El> : El extends LinkDesc<any, any, any, any> ? linkToTsType<El> : never;
export declare function isScalarType(type: BaseType): type is ScalarType;
export declare function isEnumType(type: BaseType): type is EnumType;
export declare function isObjectType(type: BaseType): type is ObjectType;
export declare function isTupleType(type: BaseType): type is TupleType;
export declare function isNamedTupleType(type: BaseType): type is NamedTupleType;
export declare function isArrayType(type: BaseType): type is ArrayType;
export declare type NonArrayType = ScalarType | EnumType | ObjectType | TupleType | NamedTupleType;
export declare type AnyTupleType = TupleType | NamedTupleType;
export declare type ParamType = ScalarType | ArrayType<ScalarType>;
export {};
