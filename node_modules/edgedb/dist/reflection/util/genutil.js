"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinFrags = exports.frag = exports.getRef = exports.makeValidIdent = exports.getInternalName = exports.displayName = exports.capitalize = exports.toTSObjectType = exports.toTSScalarType = exports.toPrimitiveJsType = exports.quote = exports.toIdent = exports.splitName = void 0;
const util_1 = require("./util");
function splitName(name) {
    if (!name.includes("::"))
        throw new Error(`Invalid FQN ${name}`);
    return {
        mod: name.split("::")[0],
        name: name.split("::")[1],
    };
}
exports.splitName = splitName;
function toIdent(name) {
    if (name.includes("::")) {
        throw new Error(`toIdent: invalid name ${name}`);
    }
    return name.replace(/([^a-zA-Z0-9_]+)/g, "_");
}
exports.toIdent = toIdent;
function quote(val) {
    return JSON.stringify(val.toString());
}
exports.quote = quote;
function toPrimitiveJsType(s, code) {
    switch (s.name) {
        case "std::int16":
        case "std::int32":
        case "std::int64":
        case "std::float32":
        case "std::float64":
            return "number";
        case "std::str":
        case "std::uuid":
        case "std::json":
            return "string";
        case "std::bool":
            return "boolean";
        case "std::bigint":
            return "BigInt";
        case "std::datetime":
            return "Date";
        case "std::duration":
            return "_.edgedb.Duration";
        case "cal::local_datetime":
            return "_.edgedb.LocalDateTime";
        case "cal::local_date":
            return "_.edgedb.LocalDate";
        case "cal::local_time":
            return "_.edgedb.LocalTime";
        case "std::decimal":
        case "std::bytes":
        default:
            return "unknown";
    }
}
exports.toPrimitiveJsType = toPrimitiveJsType;
function toTSScalarType(type, types, currentModule, code, level = 0) {
    switch (type.kind) {
        case "scalar": {
            if (type.enum_values && type.enum_values.length) {
                return [getRef(type.name, { prefix: "" })];
            }
            if (type.material_id) {
                return toTSScalarType(types.get(type.material_id), types, currentModule, code, level + 1);
            }
            return [toPrimitiveJsType(type, code)];
        }
        case "array": {
            const tn = toTSScalarType(types.get(type.array_element_id), types, currentModule, code, level + 1);
            return frag `${tn}[]`;
        }
        case "tuple": {
            if (!type.tuple_elements.length) {
                return ["[]"];
            }
            if (type.tuple_elements[0].name &&
                Number.isNaN(parseInt(type.tuple_elements[0].name, 10))) {
                const res = [];
                for (const { name, target_id } of type.tuple_elements) {
                    const tn = toTSScalarType(types.get(target_id), types, currentModule, code, level + 1);
                    res.push(frag `${name}: ${tn}`);
                }
                return frag `{${joinFrags(res, ",")}}`;
            }
            else {
                const res = [];
                for (const { target_id } of type.tuple_elements) {
                    const tn = toTSScalarType(types.get(target_id), types, currentModule, code, level + 1);
                    res.push(tn);
                }
                return frag `[${joinFrags(res, ",")}]`;
            }
        }
        default:
            util_1.util.assertNever(type);
    }
}
exports.toTSScalarType = toTSScalarType;
function toTSObjectType(type, types, currentMod, code, level = 0) {
    if (type.intersection_of && type.intersection_of.length) {
        const res = [];
        for (const { id: subId } of type.intersection_of) {
            const sub = types.get(subId);
            res.push(toTSObjectType(sub, types, currentMod, code, level + 1));
        }
        const ret = joinFrags(res, " & ");
        return level > 0 ? frag `(${ret})` : ret;
    }
    if (type.union_of && type.union_of.length) {
        const res = [];
        for (const { id: subId } of type.union_of) {
            const sub = types.get(subId);
            res.push(toTSObjectType(sub, types, currentMod, code, level + 1));
        }
        const ret = joinFrags(res, " | ");
        return level > 0 ? frag `(${ret})` : ret;
    }
    return [getRef(type.name, { prefix: "" })];
}
exports.toTSObjectType = toTSObjectType;
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
exports.capitalize = capitalize;
function displayName(str) {
    const { name } = splitName(str);
    const stripped = "$" +
        name
            .replace(/[^$0-9a-zA-Z]/g, " ")
            .split(" ")
            .filter(x => !!x)
            .map(capitalize)
            .join("");
    return stripped;
}
exports.displayName = displayName;
function getInternalName({ fqn, id }) {
    const { name } = splitName(fqn);
    return makeValidIdent({ id, name });
}
exports.getInternalName = getInternalName;
function makeValidIdent({ id, name, skipKeywordCheck, }) {
    let strippedName = name.replace(/^_|[^A-Za-z0-9_]/g, "");
    if (strippedName !== name ||
        (!skipKeywordCheck && reservedIdents.has(strippedName))) {
        strippedName += `_${id.toLowerCase().replace(/[^0-9a-f]/g, "")}`;
    }
    return strippedName;
}
exports.makeValidIdent = makeValidIdent;
function getRef(name, opts) {
    var _a;
    return {
        type: "identRef",
        name,
        opts: {
            prefix: (_a = opts === null || opts === void 0 ? void 0 : opts.prefix) !== null && _a !== void 0 ? _a : "$",
        },
    };
}
exports.getRef = getRef;
function frag(strings, ...exprs) {
    const frags = [];
    for (let i = 0; i < strings.length; i++) {
        frags.push(strings[i]);
        if (exprs[i]) {
            if (Array.isArray(exprs[i])) {
                frags.push(...exprs[i]);
            }
            else {
                frags.push(exprs[i]);
            }
        }
    }
    return frags;
}
exports.frag = frag;
function joinFrags(frags, sep) {
    const joined = [];
    for (const fragment of frags) {
        joined.push(...(Array.isArray(fragment) ? fragment : [fragment]), sep);
    }
    return joined.slice(0, -1);
}
exports.joinFrags = joinFrags;
const reservedIdents = new Set([
    "do",
    "if",
    "in",
    "for",
    "let",
    "new",
    "try",
    "var",
    "case",
    "else",
    "enum",
    "eval",
    "null",
    "this",
    "true",
    "void",
    "with",
    "await",
    "break",
    "catch",
    "class",
    "const",
    "false",
    "super",
    "throw",
    "while",
    "yield",
    "delete",
    "export",
    "import",
    "public",
    "return",
    "static",
    "switch",
    "typeof",
    "default",
    "extends",
    "finally",
    "package",
    "private",
    "continue",
    "debugger",
    "function",
    "arguments",
    "interface",
    "protected",
    "implements",
    "instanceof",
    "Object",
]);
