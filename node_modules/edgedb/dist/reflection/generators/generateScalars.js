"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateScalars = void 0;
const genutil_1 = require("../util/genutil");
const builders_1 = require("../builders");
const generateScalars = (params) => {
    var _a, _b;
    const { dir, types, casts, scalars } = params;
    for (const type of types.values()) {
        if (type.kind !== "scalar") {
            continue;
        }
        const { mod, name: _name } = (0, genutil_1.splitName)(type.name);
        const sc = dir.getModule(mod);
        sc.registerRef(type.name, type.id);
        const ref = (0, genutil_1.getRef)(type.name);
        const literal = (0, genutil_1.getRef)(type.name, { prefix: "" });
        if (type.name === "std::anyenum") {
            continue;
        }
        if (type.is_abstract) {
            const scalarType = scalars.get(type.id);
            if (scalarType.children.length) {
                const children = scalarType.children.map(desc => desc.name === "std::anyenum" ? "$.EnumType" : (0, genutil_1.getRef)(desc.name));
                sc.writeln([
                    (0, builders_1.dts) `declare `,
                    (0, builders_1.t) `type ${ref} = ${(0, genutil_1.joinFrags)(children, " | ")};`,
                ]);
                sc.writeln([
                    (0, builders_1.dts) `declare `,
                    ...(0, genutil_1.frag) `const ${ref}`,
                    (0, builders_1.t) `: ${ref}`,
                    (0, builders_1.r) ` = $.makeType`,
                    (0, builders_1.ts) `<${ref}>`,
                    (0, builders_1.r) `(_.spec, "${type.id}", _.syntax.literal);`,
                ]);
                sc.nl();
                sc.addExport(ref);
                sc.addRefsDefaultExport(ref, `$${_name}`);
            }
            else if (scalarType.bases.length) {
                const bases = scalarType.bases.map(base => (0, genutil_1.getRef)(base.name));
                sc.writeln([(0, builders_1.t) `interface ${ref} extends ${(0, genutil_1.joinFrags)(bases, ", ")} {}`]);
                sc.writeln([
                    (0, builders_1.dts) `declare `,
                    ...(0, genutil_1.frag) `const ${ref}`,
                    (0, builders_1.t) `: ${ref}`,
                    (0, builders_1.r) ` = $.makeType`,
                    (0, builders_1.ts) `<${ref}>`,
                    (0, builders_1.r) `(_.spec, "${type.id}", _.syntax.literal);`,
                ]);
                sc.nl();
                sc.addExport(ref);
                sc.addRefsDefaultExport(ref, `$${_name}`);
            }
            continue;
        }
        if (type.enum_values && type.enum_values.length) {
            sc.writeln([
                (0, builders_1.dts) `declare `,
                (0, builders_1.t) `enum `,
                (0, builders_1.js) `const `,
                ...(0, genutil_1.frag) `${ref}λEnum `,
                (0, builders_1.js) `= `,
                `{`,
            ]);
            sc.indented(() => {
                for (const val of type.enum_values) {
                    sc.writeln([(0, genutil_1.toIdent)(val), (0, builders_1.t) ` = `, (0, builders_1.js) `: `, (0, genutil_1.quote)(val), `,`]);
                }
            });
            sc.writeln([`}`]);
            sc.addExport((0, genutil_1.frag) `${ref}λEnum`);
            sc.writeln([
                (0, builders_1.t) `export `,
                (0, builders_1.dts) `declare `,
                (0, builders_1.t) `type ${ref} = typeof ${ref}λEnum & $.EnumType<${(0, genutil_1.quote)(type.name)}, ${ref}λEnum, \`\${${ref}λEnum}\`>;`,
            ]);
            sc.writeln([
                (0, builders_1.dts) `declare `,
                ...(0, genutil_1.frag) `const ${literal}`,
                (0, builders_1.t) `: ${ref}`,
                (0, builders_1.r) ` = $.makeType`,
                (0, builders_1.ts) `<${ref}>`,
                (0, builders_1.r) `(_.spec, "${type.id}", _.syntax.literal);`,
            ]);
            sc.nl();
            sc.addExport(literal);
            sc.addRefsDefaultExport(literal, _name);
            continue;
        }
        const tsType = (0, genutil_1.toTSScalarType)(type, types, mod, sc);
        sc.writeln([
            (0, builders_1.t) `export `,
            (0, builders_1.dts) `declare `,
            (0, builders_1.t) `type ${ref} = $.ScalarType<"${type.name}", ${tsType}>;`,
        ]);
        sc.writeln([
            (0, builders_1.dts) `declare `,
            ...(0, genutil_1.frag) `const ${literal}`,
            (0, builders_1.t) `: ${ref}`,
            (0, builders_1.r) ` = $.makeType`,
            (0, builders_1.ts) `<${ref}>`,
            (0, builders_1.r) `(_.spec, "${type.id}", _.syntax.literal);`,
        ]);
        if ((_a = casts.implicitCastFromMap[type.id]) === null || _a === void 0 ? void 0 : _a.length) {
            sc.writeln([
                (0, builders_1.t) `export `,
                (0, builders_1.dts) `declare `,
                (0, builders_1.t) `type ${ref}λICastableTo = ${(0, genutil_1.joinFrags)([
                    ref,
                    ...casts.implicitCastFromMap[type.id].map(typeId => (0, genutil_1.getRef)(types.get(typeId).name)),
                ], " | ")};`,
            ]);
        }
        const assignableMap = casts.assignableByMap[type.id] || [];
        if ((_b = casts.assignableByMap[type.id]) === null || _b === void 0 ? void 0 : _b.length) {
            sc.writeln([
                (0, builders_1.t) `export `,
                (0, builders_1.dts) `declare `,
                (0, builders_1.t) `type ${ref}λIAssignableBy = ${(0, genutil_1.joinFrags)(assignableMap.length
                    ? assignableMap.map(typeId => (0, genutil_1.getRef)(types.get(typeId).name))
                    : [ref], " | ")};`,
            ]);
        }
        sc.addExport(literal);
        sc.addRefsDefaultExport(literal, _name);
        sc.nl();
    }
};
exports.generateScalars = generateScalars;
