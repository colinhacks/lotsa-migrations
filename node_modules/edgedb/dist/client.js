"use strict";
/*!
 * This source file is part of the EdgeDB open source project.
 *
 * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RawConnection = exports.ConnectionImpl = exports.InnerConnection = exports.StandaloneConnection = exports.borrowError = void 0;
const adapter_node_1 = require("./adapter.node");
const buffer_1 = require("./buffer");
const chars = __importStar(require("./chars"));
const codecs_1 = require("./codecs/codecs");
const namedtuple_1 = require("./codecs/namedtuple");
const object_1 = require("./codecs/object");
const registry_1 = require("./codecs/registry");
const tuple_1 = require("./codecs/tuple");
const set_1 = require("./datatypes/set");
const errors = __importStar(require("./errors"));
const resolve_1 = require("./errors/resolve");
const ifaces_1 = require("./ifaces");
const lru_1 = __importDefault(require("./lru"));
const options_1 = require("./options");
const scram = __importStar(require("./scram"));
const transaction_1 = require("./transaction");
const utils_1 = require("./utils");
const PROTO_VER = [0, 13];
const PROTO_VER_MIN = [0, 9];
var AuthenticationStatuses;
(function (AuthenticationStatuses) {
    AuthenticationStatuses[AuthenticationStatuses["AUTH_OK"] = 0] = "AUTH_OK";
    AuthenticationStatuses[AuthenticationStatuses["AUTH_SASL"] = 10] = "AUTH_SASL";
    AuthenticationStatuses[AuthenticationStatuses["AUTH_SASL_CONTINUE"] = 11] = "AUTH_SASL_CONTINUE";
    AuthenticationStatuses[AuthenticationStatuses["AUTH_SASL_FINAL"] = 12] = "AUTH_SASL_FINAL";
})(AuthenticationStatuses || (AuthenticationStatuses = {}));
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus[TransactionStatus["TRANS_IDLE"] = 0] = "TRANS_IDLE";
    TransactionStatus[TransactionStatus["TRANS_ACTIVE"] = 1] = "TRANS_ACTIVE";
    TransactionStatus[TransactionStatus["TRANS_INTRANS"] = 2] = "TRANS_INTRANS";
    TransactionStatus[TransactionStatus["TRANS_INERROR"] = 3] = "TRANS_INERROR";
    TransactionStatus[TransactionStatus["TRANS_UNKNOWN"] = 4] = "TRANS_UNKNOWN";
})(TransactionStatus || (TransactionStatus = {}));
var Capabilities;
(function (Capabilities) {
    Capabilities[Capabilities["MODIFICATONS"] = 1] = "MODIFICATONS";
    Capabilities[Capabilities["SESSION_CONFIG"] = 2] = "SESSION_CONFIG";
    Capabilities[Capabilities["TRANSACTION"] = 4] = "TRANSACTION";
    Capabilities[Capabilities["DDL"] = 8] = "DDL";
    Capabilities[Capabilities["PERSISTENT_CONFIG"] = 16] = "PERSISTENT_CONFIG";
})(Capabilities || (Capabilities = {}));
const NO_TRANSACTION_CAPABILITIES_BYTES = Buffer.from([
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255 & ~Capabilities.TRANSACTION & ~Capabilities.SESSION_CONFIG,
]);
const OLD_ERROR_CODES = new Map([
    [84082689, 84082945],
    [84082690, 84082946],
]);
function sleep(durationMillis) {
    return new Promise((accept, reject) => {
        setTimeout(() => accept(), durationMillis);
    });
}
function borrowError(reason) {
    let text;
    switch (reason) {
        case ifaces_1.BorrowReason.TRANSACTION:
            text =
                "Connection object is borrowed for the transaction. " +
                    "Use the methods on transaction object instead.";
            break;
        case ifaces_1.BorrowReason.QUERY:
            text =
                "Another operation is in progress. Use multiple separate " +
                    "connections to run operations concurrently.";
            break;
        case ifaces_1.BorrowReason.CLOSE:
            text =
                "Connection is being closed. Use multiple separate " +
                    "connections to run operations concurrently.";
            break;
    }
    throw new errors.InterfaceError(text);
}
exports.borrowError = borrowError;
class StandaloneConnection {
    constructor(config, registry) {
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _b, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _c, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "retryingTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.transaction
        });
        this.initInner(config, registry);
        this[ifaces_1.OPTIONS] = options_1.Options.defaults();
    }
    initInner(config, registry) {
        this[ifaces_1.INNER] = new InnerConnection(config, registry);
    }
    shallowClone() {
        const result = Object.create(this.constructor.prototype);
        result[ifaces_1.INNER] = this[ifaces_1.INNER];
        result[ifaces_1.OPTIONS] = this[ifaces_1.OPTIONS];
        return result;
    }
    withTransactionOptions(opt) {
        const result = this.shallowClone();
        result[ifaces_1.OPTIONS] = this[ifaces_1.OPTIONS].withTransactionOptions(opt);
        return result;
    }
    withRetryOptions(opt) {
        const result = this.shallowClone();
        result[ifaces_1.OPTIONS] = this[ifaces_1.OPTIONS].withRetryOptions(opt);
        return result;
    }
    async rawTransaction(action) {
        let result;
        const transaction = new transaction_1.Transaction(this);
        await transaction.start();
        try {
            result = await action(transaction);
            await transaction.commit();
        }
        catch (err) {
            await transaction.rollback();
            throw err;
        }
        return result;
    }
    async transaction(action) {
        let result;
        for (let iteration = 0; iteration >= 0; ++iteration) {
            const transaction = new transaction_1.Transaction(this);
            await transaction[transaction_1.START_TRANSACTION_IMPL](iteration !== 0);
            try {
                result = await action(transaction);
            }
            catch (err) {
                try {
                    await transaction.rollback();
                }
                catch (rollback_err) {
                    if (!(rollback_err instanceof errors.EdgeDBError)) {
                        throw rollback_err;
                    }
                }
                if (err instanceof errors.EdgeDBError &&
                    err.hasTag(errors.SHOULD_RETRY)) {
                    const rule = this[ifaces_1.OPTIONS].retryOptions.getRuleForException(err);
                    if (iteration + 1 >= rule.attempts) {
                        throw err;
                    }
                    await sleep(rule.backoff(iteration + 1));
                    continue;
                }
                throw err;
            }
            await transaction.commit();
            return result;
        }
        throw Error("unreachable");
    }
    async close() {
        const borrowed_for = this[ifaces_1.INNER].borrowedFor;
        if (borrowed_for) {
            throw borrowError(borrowed_for);
        }
        this[ifaces_1.INNER].borrowedFor = ifaces_1.BorrowReason.CLOSE;
        try {
            try {
                const conn = this[ifaces_1.INNER].connection;
                if (conn) {
                    await conn.close();
                }
                this[ifaces_1.INNER].connection = undefined;
            }
            finally {
                this.cleanup();
            }
        }
        finally {
            this[ifaces_1.INNER].borrowedFor = undefined;
        }
    }
    cleanup() {
    }
    isClosed() {
        return this[ifaces_1.INNER]._isClosed;
    }
    async execute(query) {
        const inner = this[ifaces_1.INNER];
        const borrowed_for = inner.borrowedFor;
        if (borrowed_for) {
            throw borrowError(borrowed_for);
        }
        inner.borrowedFor = ifaces_1.BorrowReason.QUERY;
        let connection = inner.connection;
        if (!connection || connection.isClosed()) {
            connection = await inner.reconnect();
        }
        try {
            return await connection.execute(query);
        }
        finally {
            inner.borrowedFor = undefined;
        }
    }
    async query(query, args) {
        const inner = this[ifaces_1.INNER];
        const borrowed_for = inner.borrowedFor;
        if (borrowed_for) {
            throw borrowError(borrowed_for);
        }
        inner.borrowedFor = ifaces_1.BorrowReason.QUERY;
        let connection = inner.connection;
        if (!connection || connection.isClosed()) {
            connection = await inner.reconnect();
        }
        try {
            return await connection.fetch(query, args, false, false);
        }
        finally {
            inner.borrowedFor = undefined;
        }
    }
    async queryJSON(query, args) {
        const inner = this[ifaces_1.INNER];
        const borrowed_for = inner.borrowedFor;
        if (borrowed_for) {
            throw borrowError(borrowed_for);
        }
        inner.borrowedFor = ifaces_1.BorrowReason.QUERY;
        let connection = inner.connection;
        if (!connection || connection.isClosed()) {
            connection = await inner.reconnect();
        }
        try {
            return await connection.fetch(query, args, true, false);
        }
        finally {
            inner.borrowedFor = undefined;
        }
    }
    async querySingle(query, args) {
        const inner = this[ifaces_1.INNER];
        const borrowed_for = inner.borrowedFor;
        if (borrowed_for) {
            throw borrowError(borrowed_for);
        }
        inner.borrowedFor = ifaces_1.BorrowReason.QUERY;
        let connection = inner.connection;
        if (!connection || connection.isClosed()) {
            connection = await inner.reconnect();
        }
        try {
            return await connection.fetch(query, args, false, true);
        }
        finally {
            inner.borrowedFor = undefined;
        }
    }
    async querySingleJSON(query, args) {
        const inner = this[ifaces_1.INNER];
        const borrowed_for = inner.borrowedFor;
        if (borrowed_for) {
            throw borrowError(borrowed_for);
        }
        inner.borrowedFor = ifaces_1.BorrowReason.QUERY;
        let connection = inner.connection;
        if (!connection || connection.isClosed()) {
            connection = await inner.reconnect();
        }
        try {
            return await connection.fetch(query, args, true, true);
        }
        finally {
            inner.borrowedFor = undefined;
        }
    }
    async queryRequiredSingle(query, args) {
        const inner = this[ifaces_1.INNER];
        const borrowed_for = inner.borrowedFor;
        if (borrowed_for) {
            throw borrowError(borrowed_for);
        }
        inner.borrowedFor = ifaces_1.BorrowReason.QUERY;
        let connection = inner.connection;
        if (!connection || connection.isClosed()) {
            connection = await inner.reconnect();
        }
        try {
            return await connection.fetch(query, args, false, true, true);
        }
        finally {
            inner.borrowedFor = undefined;
        }
    }
    async queryRequiredSingleJSON(query, args) {
        const inner = this[ifaces_1.INNER];
        const borrowed_for = inner.borrowedFor;
        if (borrowed_for) {
            throw borrowError(borrowed_for);
        }
        inner.borrowedFor = ifaces_1.BorrowReason.QUERY;
        let connection = inner.connection;
        if (!connection || connection.isClosed()) {
            connection = await inner.reconnect();
        }
        try {
            return await connection.fetch(query, args, true, true, true);
        }
        finally {
            inner.borrowedFor = undefined;
        }
    }
    static async connect(config, registry) {
        const conn = new this(config, registry);
        await conn[ifaces_1.INNER].reconnect();
        return conn;
    }
}
exports.StandaloneConnection = StandaloneConnection;
_a = ifaces_1.ALLOW_MODIFICATIONS, _b = ifaces_1.INNER, _c = ifaces_1.OPTIONS;
class InnerConnection {
    constructor(config, registry) {
        Object.defineProperty(this, "borrowedFor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "connection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "registry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.config = config;
        this.registry = registry;
    }
    async getImpl(singleAttempt = false) {
        let connection = this.connection;
        if (!connection || connection.isClosed()) {
            connection = await this.reconnect(singleAttempt);
        }
        return connection;
    }
    get _isClosed() {
        var _d, _e;
        return (_e = (_d = this.connection) === null || _d === void 0 ? void 0 : _d.isClosed()) !== null && _e !== void 0 ? _e : false;
    }
    logConnectionError(...args) {
        if (!this.config.logging) {
            return;
        }
        if (this.config.inProject &&
            !this.config.fromProject &&
            !this.config.fromEnv) {
            args.push(`\n\n\n` +
                `Hint: it looks like the program is running from a ` +
                `directory initialized with "edgedb project init". ` +
                `Consider calling "edgedb.connect()" without arguments.` +
                `\n`);
        }
        console.warn(...args);
    }
    async reconnect(singleAttempt = false) {
        let maxTime;
        if (singleAttempt || this.config.waitUntilAvailable === 0) {
            maxTime = 0;
        }
        else {
            maxTime = (0, adapter_node_1.hrTime)() + (this.config.waitUntilAvailable || 0);
        }
        let iteration = 1;
        let lastLoggingAt = 0;
        while (true) {
            for (const addr of [this.config.connectionParams.address]) {
                try {
                    this.connection = await ConnectionImpl.connectWithTimeout(addr, this.config, this.registry);
                    return this.connection;
                }
                catch (e) {
                    if (e instanceof errors.ClientConnectionError) {
                        if (e.hasTag(errors.SHOULD_RECONNECT)) {
                            const now = (0, adapter_node_1.hrTime)();
                            if (iteration > 1 && now > maxTime) {
                                throw e;
                            }
                            if (iteration > 1 &&
                                (!lastLoggingAt || now - lastLoggingAt > 5000)) {
                                lastLoggingAt = now;
                                this.logConnectionError(`A client connection error occurred; reconnecting because ` +
                                    `of "waitUntilAvailable=${this.config.waitUntilAvailable}".`, e);
                            }
                            continue;
                        }
                        else {
                            throw e;
                        }
                    }
                    else {
                        console.error("Unexpected connection error:", e);
                        throw e;
                    }
                }
            }
            iteration += 1;
            await sleep(Math.trunc(10 + Math.random() * 200));
        }
    }
}
exports.InnerConnection = InnerConnection;
class ConnectionImpl {
    constructor(sock, config, registry) {
        Object.defineProperty(this, "sock", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "paused", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "connected", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "lastStatus", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "codecsRegistry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "queryCodecCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "serverSecret", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "serverSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "serverXactStatus", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "buffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "messageWaiterResolve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "messageWaiterReject", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "connWaiter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "connWaiterResolve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "connWaiterReject", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "protocolVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: PROTO_VER
        });
        Object.defineProperty(this, "_abortedWith", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        this.buffer = new buffer_1.ReadMessageBuffer();
        this.codecsRegistry = registry;
        this.queryCodecCache = new lru_1.default({ capacity: 1000 });
        this.lastStatus = null;
        this.serverSecret = null;
        this.serverSettings = {};
        this.serverXactStatus = TransactionStatus.TRANS_UNKNOWN;
        this.messageWaiterResolve = null;
        this.messageWaiterReject = null;
        this.connWaiterResolve = null;
        this.connWaiterReject = null;
        this.connWaiter = new Promise((resolve, reject) => {
            this.connWaiterResolve = resolve;
            this.connWaiterReject = reject;
        });
        this.paused = false;
        this.sock = sock;
        this.sock.setNoDelay();
        this.sock.on("error", this._onError.bind(this));
        this.sock.on("data", this._onData.bind(this));
        if (this.sock instanceof adapter_node_1.tls.TLSSocket) {
            this.sock.on("secureConnect", this._onConnect.bind(this));
        }
        else {
            this.sock.on("connect", this._onConnect.bind(this));
        }
        this.sock.on("close", this._onClose.bind(this));
        this.config = config;
    }
    async _waitForMessage() {
        if (this.buffer.takeMessage()) {
            return;
        }
        if (this.paused) {
            this.paused = false;
            this.sock.resume();
        }
        this.sock.ref();
        try {
            await new Promise((resolve, reject) => {
                this.messageWaiterResolve = resolve;
                this.messageWaiterReject = reject;
            });
        }
        finally {
            this.sock.unref();
        }
    }
    _onConnect() {
        if (this.connWaiterResolve) {
            this.connWaiterResolve(true);
            this.connWaiterReject = null;
            this.connWaiterResolve = null;
        }
    }
    _abortWaiters(err) {
        if (this.connWaiterReject) {
            this.connWaiterReject(err);
            this.connWaiterReject = null;
            this.connWaiterResolve = null;
        }
        if (this.messageWaiterReject) {
            this.messageWaiterReject(err);
            this.messageWaiterResolve = null;
            this.messageWaiterReject = null;
        }
    }
    _onClose() {
        if (!this.connected) {
            return;
        }
        const newErr = new errors.ClientConnectionClosedError(`the connection has been aborted`);
        if (this.connWaiterReject || this.messageWaiterReject) {
            this._abortWaiters(newErr);
        }
        this._abortWithError(newErr);
    }
    _onError(err) {
        const newErr = new errors.ClientConnectionClosedError(`network error: ${err}`);
        newErr.source = err;
        try {
            this._abortWaiters(newErr);
        }
        finally {
            this._abortWithError(newErr);
        }
    }
    _abortWithError(err) {
        this._abortedWith = err;
        this._abort();
    }
    _checkState() {
        if (this._abortedWith != null) {
            throw this._abortedWith;
        }
    }
    _onData(data) {
        let pause = false;
        try {
            pause = this.buffer.feed(data);
        }
        catch (e) {
            if (this.messageWaiterReject) {
                this.messageWaiterReject(e);
            }
            else {
                throw e;
            }
        }
        if (pause) {
            this.paused = true;
            this.sock.pause();
        }
        if (this.messageWaiterResolve) {
            if (this.buffer.takeMessage()) {
                this.messageWaiterResolve(true);
                this.messageWaiterResolve = null;
                this.messageWaiterReject = null;
            }
        }
    }
    _ignoreHeaders() {
        let numFields = this.buffer.readInt16();
        while (numFields) {
            this.buffer.readInt16();
            this.buffer.readLenPrefixedBuffer();
            numFields--;
        }
    }
    _parseHeaders() {
        const ret = new Map();
        let numFields = this.buffer.readInt16();
        while (numFields) {
            const key = this.buffer.readInt16();
            const value = this.buffer.readLenPrefixedBuffer();
            ret.set(key, value);
            numFields--;
        }
        return ret;
    }
    _parseDescribeTypeMessage() {
        this._ignoreHeaders();
        const cardinality = this.buffer.readChar();
        const inTypeId = this.buffer.readUUID();
        const inTypeData = this.buffer.readLenPrefixedBuffer();
        const outTypeId = this.buffer.readUUID();
        const outTypeData = this.buffer.readLenPrefixedBuffer();
        this.buffer.finishMessage();
        let inCodec = this.codecsRegistry.getCodec(inTypeId);
        if (inCodec == null) {
            inCodec = this.codecsRegistry.buildCodec(inTypeData, this.protocolVersion);
        }
        let outCodec = this.codecsRegistry.getCodec(outTypeId);
        if (outCodec == null) {
            outCodec = this.codecsRegistry.buildCodec(outTypeData, this.protocolVersion);
        }
        return [cardinality, inCodec, outCodec, inTypeData, outTypeData];
    }
    _parseCommandCompleteMessage() {
        this._ignoreHeaders();
        const status = this.buffer.readString();
        this.buffer.finishMessage();
        return status;
    }
    _parseErrorMessage() {
        var _d;
        const severity = this.buffer.readChar();
        const code = this.buffer.readUInt32();
        const message = this.buffer.readString();
        const attrs = this._parseHeaders();
        const errorType = (0, resolve_1.resolveErrorCode)((_d = OLD_ERROR_CODES.get(code)) !== null && _d !== void 0 ? _d : code);
        this.buffer.finishMessage();
        const err = new errorType(message);
        return err;
    }
    _parseSyncMessage() {
        this._parseHeaders();
        const status = this.buffer.readChar();
        switch (status) {
            case chars.$I:
                this.serverXactStatus = TransactionStatus.TRANS_IDLE;
                break;
            case chars.$T:
                this.serverXactStatus = TransactionStatus.TRANS_INTRANS;
                break;
            case chars.$E:
                this.serverXactStatus = TransactionStatus.TRANS_INERROR;
                break;
            default:
                this.serverXactStatus = TransactionStatus.TRANS_UNKNOWN;
        }
        this.buffer.finishMessage();
    }
    _parseDataMessages(codec, result) {
        const frb = buffer_1.ReadBuffer.alloc();
        const $D = chars.$D;
        const buffer = this.buffer;
        if (Array.isArray(result)) {
            while (buffer.takeMessageType($D)) {
                buffer.consumeMessageInto(frb);
                frb.discard(6);
                result.push(codec.decode(frb));
                frb.finish();
            }
        }
        else {
            while (buffer.takeMessageType($D)) {
                const msg = buffer.consumeMessage();
                result.writeChar($D);
                result.writeInt32(msg.length + 4);
                result.writeBuffer(msg);
            }
        }
    }
    _parseServerSettings(name, value) {
        switch (name) {
            case "suggested_pool_concurrency":
                this.serverSettings.suggested_pool_concurrency = parseInt(value.toString("utf8"), 10);
                break;
            case "system_config":
                const buf = new buffer_1.ReadBuffer(value);
                const typedescLen = buf.readInt32() - 16;
                const typedescId = buf.readUUID();
                const typedesc = buf.readBuffer(typedescLen);
                let codec = this.codecsRegistry.getCodec(typedescId);
                if (codec === null) {
                    codec = this.codecsRegistry.buildCodec(typedesc, this.protocolVersion);
                }
                buf.discard(4);
                const data = codec.decode(buf);
                buf.finish();
                this.serverSettings.system_config = data;
                break;
            default:
                this.serverSettings[name] = value;
                break;
        }
    }
    _fallthrough() {
        const mtype = this.buffer.getMessageType();
        switch (mtype) {
            case chars.$S: {
                const name = this.buffer.readString();
                const value = this.buffer.readLenPrefixedBuffer();
                this._parseServerSettings(name, value);
                this.buffer.finishMessage();
                break;
            }
            case chars.$L: {
                const severity = this.buffer.readChar();
                const code = this.buffer.readUInt32();
                const message = this.buffer.readString();
                this._parseHeaders();
                this.buffer.finishMessage();
                console.info("SERVER MESSAGE", severity, code, message);
                break;
            }
            default:
                throw new Error(`unexpected message type ${mtype} ("${chars.chr(mtype)}")`);
        }
    }
    static async connectWithTimeout(addr, config, registry, useTls = true) {
        const sock = this.newSock(addr, useTls ? config.connectionParams.tlsOptions : undefined);
        const conn = new this(sock, config, registry);
        const connPromise = conn.connect();
        let timeoutCb = null;
        let timeoutHappened = false;
        if (config.connectTimeout) {
            timeoutCb = setTimeout(() => {
                if (!conn.connected) {
                    timeoutHappened = true;
                    conn.sock.destroy(new errors.ClientConnectionTimeoutError(`connection timed out (${config.connectTimeout}ms)`));
                }
            }, config.connectTimeout);
        }
        try {
            await connPromise;
        }
        catch (e) {
            conn._abort();
            if (timeoutHappened && e instanceof errors.ClientConnectionClosedError) {
                throw new errors.ClientConnectionTimeoutError(`connection timed out (${config.connectTimeout}ms)`);
            }
            if (e instanceof errors.EdgeDBError) {
                throw e;
            }
            else {
                let err;
                switch (e.code) {
                    case "EPROTO":
                        if (useTls === true) {
                            try {
                                return this.connectWithTimeout(addr, config, registry, false);
                            }
                            catch {
                            }
                        }
                        err = new errors.ClientConnectionFailedError(`${e.message}\n` +
                            `Attempted to connect using the following credentials:\n` +
                            `${config.connectionParams.explainConfig()}\n`);
                        break;
                    case "ECONNREFUSED":
                    case "ECONNABORTED":
                    case "ECONNRESET":
                    case "ENOTFOUND":
                    case "ENOENT":
                        err = new errors.ClientConnectionFailedTemporarilyError(`${e.message}\n` +
                            `Attempted to connect using the following credentials:\n` +
                            `${config.connectionParams.explainConfig()}\n`);
                        break;
                    default:
                        err = new errors.ClientConnectionFailedError(`${e.message}\n` +
                            `Attempted to connect using the following credentials:\n` +
                            `${config.connectionParams.explainConfig()}\n`);
                        break;
                }
                err.source = e;
                throw err;
            }
        }
        finally {
            if (timeoutCb != null) {
                clearTimeout(timeoutCb);
            }
        }
        return conn;
    }
    async connect() {
        await this.connWaiter;
        if (this.sock instanceof adapter_node_1.tls.TLSSocket) {
            if (this.sock.alpnProtocol !== "edgedb-binary") {
                throw new errors.ClientConnectionFailedError("The server doesn't support the edgedb-binary protocol.");
            }
        }
        const handshake = new buffer_1.WriteMessageBuffer();
        handshake
            .beginMessage(chars.$V)
            .writeInt16(this.protocolVersion[0])
            .writeInt16(this.protocolVersion[1]);
        handshake.writeInt16(2);
        handshake.writeString("user");
        handshake.writeString(this.config.connectionParams.user);
        handshake.writeString("database");
        handshake.writeString(this.config.connectionParams.database);
        handshake.writeInt16(0);
        handshake.endMessage();
        this.sock.write(handshake.unwrap());
        while (true) {
            if (!this.buffer.takeMessage()) {
                await this._waitForMessage();
            }
            const mtype = this.buffer.getMessageType();
            switch (mtype) {
                case chars.$v: {
                    const hi = this.buffer.readInt16();
                    const lo = this.buffer.readInt16();
                    this._parseHeaders();
                    this.buffer.finishMessage();
                    const proposed = [hi, lo];
                    if ((0, utils_1.versionGreaterThan)(proposed, PROTO_VER) ||
                        (0, utils_1.versionGreaterThan)(PROTO_VER_MIN, proposed)) {
                        throw new Error(`the server requested an unsupported version of ` +
                            `the protocol ${hi}.${lo}`);
                    }
                    this.protocolVersion = [hi, lo];
                    break;
                }
                case chars.$R: {
                    const status = this.buffer.readInt32();
                    if (status === AuthenticationStatuses.AUTH_OK) {
                        this.buffer.finishMessage();
                    }
                    else if (status === AuthenticationStatuses.AUTH_SASL) {
                        await this._authSasl();
                    }
                    else {
                        throw new Error(`unsupported authentication method requested by the ` +
                            `server: ${status}`);
                    }
                    break;
                }
                case chars.$K: {
                    this.serverSecret = this.buffer.readBuffer(32);
                    this.buffer.finishMessage();
                    break;
                }
                case chars.$E: {
                    throw this._parseErrorMessage();
                }
                case chars.$Z: {
                    this._parseSyncMessage();
                    if (!(this.sock instanceof adapter_node_1.tls.TLSSocket) &&
                        typeof Deno === "undefined" &&
                        (0, utils_1.versionGreaterThanOrEqual)(this.protocolVersion, [0, 11])) {
                        const [major, minor] = this.protocolVersion;
                        throw new Error(`the protocol version requires TLS: ${major}.${minor}`);
                    }
                    this.connected = true;
                    return;
                }
                default:
                    this._fallthrough();
            }
        }
    }
    async _authSasl() {
        const numMethods = this.buffer.readInt32();
        if (numMethods <= 0) {
            throw new Error("the server requested SASL authentication but did not offer any methods");
        }
        const methods = [];
        let foundScram256 = false;
        for (let _ = 0; _ < numMethods; _++) {
            const method = this.buffer.readLenPrefixedBuffer().toString("utf8");
            if (method === "SCRAM-SHA-256") {
                foundScram256 = true;
            }
            methods.push(method);
        }
        this.buffer.finishMessage();
        if (!foundScram256) {
            throw new Error(`the server offered the following SASL authentication ` +
                `methods: ${methods.join(", ")}, neither are supported.`);
        }
        const clientNonce = await scram.generateNonce();
        const [clientFirst, clientFirstBare] = scram.buildClientFirstMessage(clientNonce, this.config.connectionParams.user);
        const wb = new buffer_1.WriteMessageBuffer();
        wb.beginMessage(chars.$p)
            .writeString("SCRAM-SHA-256")
            .writeString(clientFirst)
            .endMessage();
        this.sock.write(wb.unwrap());
        await this._ensureMessage(chars.$R, "SASLContinue");
        let status = this.buffer.readInt32();
        if (status !== AuthenticationStatuses.AUTH_SASL_CONTINUE) {
            throw new Error(`expected SASLContinue from the server, received ${status}`);
        }
        const serverFirst = this.buffer.readString();
        this.buffer.finishMessage();
        const [serverNonce, salt, itercount] = scram.parseServerFirstMessage(serverFirst);
        const [clientFinal, expectedServerSig] = scram.buildClientFinalMessage(this.config.connectionParams.password || "", salt, itercount, clientFirstBare, serverFirst, serverNonce);
        wb.reset().beginMessage(chars.$r).writeString(clientFinal).endMessage();
        this.sock.write(wb.unwrap());
        await this._ensureMessage(chars.$R, "SASLFinal");
        status = this.buffer.readInt32();
        if (status !== AuthenticationStatuses.AUTH_SASL_FINAL) {
            throw new Error(`expected SASLFinal from the server, received ${status}`);
        }
        const serverFinal = this.buffer.readString();
        this.buffer.finishMessage();
        const serverSig = scram.parseServerFinalMessage(serverFinal);
        if (!serverSig.equals(expectedServerSig)) {
            throw new Error("server SCRAM proof does not match");
        }
    }
    async _ensureMessage(expectedMtype, err) {
        if (!this.buffer.takeMessage()) {
            await this._waitForMessage();
        }
        const mtype = this.buffer.getMessageType();
        switch (mtype) {
            case chars.$E: {
                throw this._parseErrorMessage();
            }
            case expectedMtype: {
                return;
            }
            default: {
                throw new Error(`expected ${err} from the server, received ${chars.chr(mtype)}`);
            }
        }
    }
    async _parse(query, asJson, expectOne, alwaysDescribe, options) {
        var _d;
        const wb = new buffer_1.WriteMessageBuffer();
        wb.beginMessage(chars.$P)
            .writeHeaders({
            ...((_d = options === null || options === void 0 ? void 0 : options.headers) !== null && _d !== void 0 ? _d : {}),
            allowCapabilities: NO_TRANSACTION_CAPABILITIES_BYTES,
        })
            .writeChar(asJson ? chars.$j : chars.$b)
            .writeChar(expectOne ? chars.$o : chars.$m)
            .writeString("")
            .writeString(query)
            .endMessage();
        wb.writeSync();
        this.sock.write(wb.unwrap());
        let cardinality;
        let inTypeId;
        let outTypeId;
        let inCodec;
        let outCodec;
        let parsing = true;
        let error = null;
        let inCodecData = null;
        let outCodecData = null;
        while (parsing) {
            if (!this.buffer.takeMessage()) {
                await this._waitForMessage();
            }
            const mtype = this.buffer.getMessageType();
            switch (mtype) {
                case chars.$1: {
                    this._ignoreHeaders();
                    cardinality = this.buffer.readChar();
                    inTypeId = this.buffer.readUUID();
                    outTypeId = this.buffer.readUUID();
                    this.buffer.finishMessage();
                    break;
                }
                case chars.$E: {
                    error = this._parseErrorMessage();
                    break;
                }
                case chars.$Z: {
                    this._parseSyncMessage();
                    parsing = false;
                    break;
                }
                default:
                    this._fallthrough();
            }
        }
        if (error != null) {
            throw error;
        }
        if (inTypeId == null || outTypeId == null) {
            throw new Error("did not receive in/out type ids in Parse response");
        }
        inCodec = this.codecsRegistry.getCodec(inTypeId);
        outCodec = this.codecsRegistry.getCodec(outTypeId);
        if (inCodec == null || outCodec == null || alwaysDescribe) {
            wb.reset();
            wb.beginMessage(chars.$D)
                .writeInt16(0)
                .writeChar(chars.$T)
                .writeString("")
                .endMessage()
                .writeSync();
            this.sock.write(wb.unwrap());
            parsing = true;
            while (parsing) {
                if (!this.buffer.takeMessage()) {
                    await this._waitForMessage();
                }
                const mtype = this.buffer.getMessageType();
                switch (mtype) {
                    case chars.$T: {
                        try {
                            [cardinality, inCodec, outCodec, inCodecData, outCodecData] =
                                this._parseDescribeTypeMessage();
                        }
                        catch (e) {
                            error = e;
                        }
                        break;
                    }
                    case chars.$E: {
                        error = this._parseErrorMessage();
                        break;
                    }
                    case chars.$Z: {
                        this._parseSyncMessage();
                        parsing = false;
                        break;
                    }
                    default:
                        this._fallthrough();
                }
            }
            if (error != null) {
                throw error;
            }
        }
        if (cardinality == null || outCodec == null || inCodec == null) {
            throw new Error("failed to receive type information in response to a Parse message");
        }
        return [cardinality, inCodec, outCodec, inCodecData, outCodecData];
    }
    _encodeArgs(args, inCodec) {
        if ((0, utils_1.versionGreaterThanOrEqual)(this.protocolVersion, [0, 12])) {
            if (inCodec === codecs_1.NULL_CODEC && !args) {
                return codecs_1.NullCodec.BUFFER;
            }
            if (inCodec instanceof object_1.ObjectCodec) {
                return inCodec.encodeArgs(args);
            }
            throw new Error("invalid input codec");
        }
        else {
            if (inCodec === tuple_1.EMPTY_TUPLE_CODEC && !args) {
                return tuple_1.EmptyTupleCodec.BUFFER;
            }
            if (inCodec instanceof namedtuple_1.NamedTupleCodec ||
                inCodec instanceof tuple_1.TupleCodec) {
                return inCodec.encodeArgs(args);
            }
            throw new Error("invalid input codec");
        }
    }
    async _executeFlow(args, inCodec, outCodec, result) {
        const wb = new buffer_1.WriteMessageBuffer();
        wb.beginMessage(chars.$E)
            .writeHeaders({ allowCapabilities: NO_TRANSACTION_CAPABILITIES_BYTES })
            .writeString("")
            .writeBuffer(args instanceof Buffer ? args : this._encodeArgs(args, inCodec))
            .endMessage()
            .writeSync();
        this.sock.write(wb.unwrap());
        let parsing = true;
        let error = null;
        while (parsing) {
            if (!this.buffer.takeMessage()) {
                await this._waitForMessage();
            }
            const mtype = this.buffer.getMessageType();
            switch (mtype) {
                case chars.$D: {
                    if (error == null) {
                        try {
                            this._parseDataMessages(outCodec, result);
                        }
                        catch (e) {
                            error = e;
                            this.buffer.finishMessage();
                        }
                    }
                    else {
                        this.buffer.discardMessage();
                    }
                    break;
                }
                case chars.$C: {
                    this.lastStatus = this._parseCommandCompleteMessage();
                    break;
                }
                case chars.$E: {
                    error = this._parseErrorMessage();
                    break;
                }
                case chars.$Z: {
                    this._parseSyncMessage();
                    parsing = false;
                    break;
                }
                default:
                    this._fallthrough();
            }
        }
        if (error != null) {
            throw error;
        }
    }
    async _optimisticExecuteFlow(args, asJson, expectOne, requiredOne, inCodec, outCodec, query, result) {
        const wb = new buffer_1.WriteMessageBuffer();
        wb.beginMessage(chars.$O);
        wb.writeHeaders({ allowCapabilities: NO_TRANSACTION_CAPABILITIES_BYTES });
        wb.writeChar(asJson ? chars.$j : chars.$b);
        wb.writeChar(expectOne ? chars.$o : chars.$m);
        wb.writeString(query);
        wb.writeBuffer(inCodec.tidBuffer);
        wb.writeBuffer(outCodec.tidBuffer);
        wb.writeBuffer(this._encodeArgs(args, inCodec));
        wb.endMessage();
        wb.writeSync();
        this.sock.write(wb.unwrap());
        let reExec = false;
        let error = null;
        let parsing = true;
        let newCard = null;
        while (parsing) {
            if (!this.buffer.takeMessage()) {
                await this._waitForMessage();
            }
            const mtype = this.buffer.getMessageType();
            switch (mtype) {
                case chars.$D: {
                    if (error == null) {
                        try {
                            this._parseDataMessages(outCodec, result);
                        }
                        catch (e) {
                            error = e;
                            this.buffer.finishMessage();
                        }
                    }
                    else {
                        this.buffer.discardMessage();
                    }
                    break;
                }
                case chars.$C: {
                    this.lastStatus = this._parseCommandCompleteMessage();
                    break;
                }
                case chars.$Z: {
                    this._parseSyncMessage();
                    parsing = false;
                    break;
                }
                case chars.$T: {
                    try {
                        [newCard, inCodec, outCodec] = this._parseDescribeTypeMessage();
                        const key = this._getQueryCacheKey(query, asJson, expectOne);
                        this.queryCodecCache.set(key, [newCard, inCodec, outCodec]);
                        reExec = true;
                    }
                    catch (e) {
                        error = e;
                    }
                    break;
                }
                case chars.$E: {
                    error = this._parseErrorMessage();
                    break;
                }
                default:
                    this._fallthrough();
            }
        }
        if (error != null) {
            throw error;
        }
        if (reExec) {
            this._validateFetchCardinality(newCard, asJson, requiredOne);
            return await this._executeFlow(args, inCodec, outCodec, result);
        }
    }
    _getQueryCacheKey(query, asJson, expectOne) {
        return [asJson, expectOne, query.length, query].join(";");
    }
    _validateFetchCardinality(card, asJson, requiredOne) {
        if (requiredOne && card === chars.$n) {
            throw new errors.NoDataError(`query executed via queryRequiredSingle${asJson ? "JSON" : ""}() returned no data`);
        }
    }
    async fetch(query, args = null, asJson, expectOne, requiredOne = false) {
        var _d;
        this._checkState();
        const key = this._getQueryCacheKey(query, asJson, expectOne);
        const ret = new set_1.Set();
        if (this.queryCodecCache.has(key)) {
            const [card, inCodec, outCodec] = this.queryCodecCache.get(key);
            this._validateFetchCardinality(card, asJson, requiredOne);
            await this._optimisticExecuteFlow(args, asJson, expectOne, requiredOne, inCodec, outCodec, query, ret);
        }
        else {
            const [card, inCodec, outCodec] = await this._parse(query, asJson, expectOne, false);
            this._validateFetchCardinality(card, asJson, requiredOne);
            this.queryCodecCache.set(key, [card, inCodec, outCodec]);
            await this._executeFlow(args, inCodec, outCodec, ret);
        }
        if (expectOne) {
            if (requiredOne && !ret.length) {
                throw new errors.NoDataError("query returned no data");
            }
            else {
                return (_d = ret[0]) !== null && _d !== void 0 ? _d : (asJson ? "null" : null);
            }
        }
        else {
            if (ret && ret.length) {
                if (asJson) {
                    return ret[0];
                }
                else {
                    return ret;
                }
            }
            else {
                if (asJson) {
                    return "[]";
                }
                else {
                    return ret;
                }
            }
        }
    }
    async execute(query, allowTransactionCommands = false) {
        this._checkState();
        const wb = new buffer_1.WriteMessageBuffer();
        wb.beginMessage(chars.$Q)
            .writeHeaders({
            allowCapabilities: !allowTransactionCommands
                ? NO_TRANSACTION_CAPABILITIES_BYTES
                : undefined,
        })
            .writeString(query)
            .endMessage();
        this.sock.write(wb.unwrap());
        let error = null;
        let parsing = true;
        while (parsing) {
            if (!this.buffer.takeMessage()) {
                await this._waitForMessage();
            }
            const mtype = this.buffer.getMessageType();
            switch (mtype) {
                case chars.$C: {
                    this.lastStatus = this._parseCommandCompleteMessage();
                    break;
                }
                case chars.$Z: {
                    this._parseSyncMessage();
                    parsing = false;
                    break;
                }
                case chars.$E: {
                    error = this._parseErrorMessage();
                    break;
                }
                default:
                    this._fallthrough();
            }
        }
        if (error != null) {
            throw error;
        }
    }
    async resetState() {
        if (this.serverXactStatus !== TransactionStatus.TRANS_IDLE) {
            try {
                await this.fetch(`rollback`, null, false, false);
            }
            catch {
                this.close();
            }
        }
    }
    _abort() {
        if (this.sock && this.connected) {
            this.sock.destroy();
        }
        this.connected = false;
    }
    isClosed() {
        return !this.connected;
    }
    async close() {
        if (this.sock && this.connected) {
            this.sock.write(new buffer_1.WriteMessageBuffer().beginMessage(chars.$X).endMessage().unwrap());
        }
        this._abort();
    }
    static newSock(addr, options) {
        if (typeof addr === "string") {
            return adapter_node_1.net.createConnection(addr);
        }
        const [host, port] = addr;
        if (options == null) {
            return adapter_node_1.net.createConnection(port, host);
        }
        const opts = { ...options, host, port };
        return adapter_node_1.tls.connect(opts);
    }
}
exports.ConnectionImpl = ConnectionImpl;
class RawConnection extends ConnectionImpl {
    static async connectWithTimeout(addr, config) {
        const registry = new registry_1.CodecsRegistry();
        return ConnectionImpl.connectWithTimeout.call(RawConnection, addr, config, registry);
    }
    async rawParse(query, headers) {
        const result = await this._parse(query, false, false, true, { headers });
        return [result[3], result[4], this.protocolVersion];
    }
    async rawExecute(encodedArgs = null) {
        const result = new buffer_1.WriteBuffer();
        let inCodec = tuple_1.EMPTY_TUPLE_CODEC;
        if ((0, utils_1.versionGreaterThanOrEqual)(this.protocolVersion, [0, 12])) {
            inCodec = codecs_1.NULL_CODEC;
        }
        await this._executeFlow(encodedArgs, inCodec, tuple_1.EMPTY_TUPLE_CODEC, result);
        return result.unwrap();
    }
    async execute(query) {
        throw new Error("not implemented");
    }
    async query(query, args = null) {
        throw new Error("not implemented");
    }
    async querySingle(query, args = null) {
        throw new Error("not implemented");
    }
    async queryJSON(query, args = null) {
        throw new Error("not implemented");
    }
    async querySingleJSON(query, args = null) {
        throw new Error("not implemented");
    }
}
exports.RawConnection = RawConnection;
